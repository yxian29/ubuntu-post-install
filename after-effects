#!/usr/bin/env bash
# shellcheck disable=SC2059
# Legal Preamble:
#
# This script is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3.
#
# This script is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, see <https://www.gnu.org/licenses/gpl-3.0.txt>

# Author: Prasad Tengse
# Licence: GPLv3
# Github Repository: https://github.com/tprasadtp/ubuntu-post-install
# Requirements - Bash v4 and above
#              - whiptail, lsb-release, wget, iputils-ping
#              - Ubuntu 14.04/16.04/17.04/17.10/18.04 or Elementary Freya/Loki/Juno
#              - Mint 17.X or 18.X or 19.X
#              - Debian 8 & 9
#

set -o pipefail
#Constants
readonly EXEC_START=$(date +%s)
readonly DATE=$(date +%Y-%m-%d:%H:%M:%S)
readonly SCRIPT=$(basename "$0")
readonly dir=$(cd -P -- "$(dirname -- "$0")" && pwd -P)
readonly REL_NAME="5.3.7 Beta"
readonly REL_NUM=537

function _init_printf_variables()
{
  #Initialize printf variables

    #================ Because I care about Beauty of Output Logs =================
    readonly           _repo="[    Add-Repo   ]"
    readonly            _ppa="[      PPA      ]"
    readonly          _oh_no="[     Oh No!    ]"
    readonly     _installing="[   Installing  ]"
    readonly      _installed="[   Installed   ]"
    readonly       _removing="[    Removing   ]"
    readonly        _removed="[    Removed    ]"
    readonly       _deleting="[    Deleting   ]"
    readonly      _linuxmint="[  Linux - Mint ]"
    readonly     _elementary="[ Elementary-OS ]"
    readonly      _canonical="[  Canonical-y  ]"
    readonly          _purge="[     Purge     ]"
    readonly          _error="[     Error!    ]"
    readonly         _update="[     Update    ]"
    readonly        _upgrade="[    Upgrade    ]"
    readonly    _derivatives="[  Derivatives  ]"
    readonly      _conflicts="[   Conflicts   ]"
    readonly         _notice="[    Notice     ]"
    readonly            _deb="[   Debian-PKG  ]"
    readonly           _info="[     Info      ]"
    readonly       _simulate="[   Simulating  ]"
    readonly       _fix_repo="[      Fix      ]"
    readonly           _warn="[    Warning    ]"
    readonly         _whoops="[     Oops!     ]"
    readonly    _pre_release="[  Pre Release  ]"
    readonly    _new_release="[  New Release  ]"
    readonly        _version="[    Version    ]"
    readonly       _checking="[    Checking   ]"
    readonly            _eol="[      EOL      ]"
    readonly        _running="[    Running    ]"
    readonly      _autopilot="[   Autopilot   ]"
    readonly            _api="[      API      ]"
    readonly          _debug="[     DEBUG     ]"
    readonly       _ppa_logs="[    PPA-Logs   ]"
    readonly       _apt_logs="[    APT-Logs   ]"
    readonly      _dpkg_logs="[    PKG-Logs   ]"
    readonly   _apt_key_logs="[  APT-Key-Logs ]"
    readonly       _pip_logs="[    PIP-Logs   ]"
    readonly     _conda_logs="[   Conda-Logs  ]"
    readonly            _cfg="[    R-Config   ]"
    readonly         _rtasks="[    R-Tasks    ]"
    readonly             _ci="[      C-I      ]"
    readonly          _table="[  ---Table---  ]"
    readonly          _array="[   PKG Array   ]"
    readonly            _apt="[  APT-Packges  ]"
    readonly           _list="[  Cleaned List ]"
    #readonly           _falg="[     Flag      ]"

    #colors for display
    readonly BLUE=$(tput setaf 6)
    readonly YELLOW=$(tput setaf 3)
    readonly NC=$(tput sgr 0)
    readonly MAGENTA=$(tput setaf 5)

}


function _init_logging()
{
  # Initialize phase 2
  # Only variables necessary for logging & start logging
  # Script relatead variables are defined in _init_script_variables
  readonly log_file="$dir"/logs/after-effects.log
  {
    mkdir -p "$dir"/logs
  } ||
  {
    printf "${_error} Failed to Create logs folder\n"; exit 2
  }
  # tmp dir
  {
    rm -rf /tmp/ae/*
    mkdir -p /tmp/ae/
  } ||
  {
    printf "${_error} Failed to Create tmp folder\n"; exit 2
  }
  _debug_log "Executing Script"
  _line_fill >> "$log_file"
}


# Utility Functions
function _line_fill()
{
  printf "%-$(tput cols)s@%s\n" | sed -e "s/ /-/g" -e "s/-@/ /" -e "s/@-/ /"
}


function set_blue()
{
  tput setaf 6
}


function set_yellow()
{
  tput setaf 3
}

function set_green()
{
  tput setaf 10
}


function set_magenta()
{
  tput setaf 5
}


function set_red()
{
  tput setaf 1
}


function set_default()
{
  tput sgr 0
}


function _goodbye_msg ()
{
  printf "\n$(tput setaf 3)It was a pleasure helping you,\nHave a great time with this Linux Machine.\nWith loads of love,\n$(tput setaf 6)${SCRIPT} running on $(uname -n)$(tput sgr 0)\n"
}


function _log_and_exit()
{
  # ARG-1 log msg
  # ARG-2 exit code int
  local msg="$1"
  printf "$msg\n";
  {
    printf "[$(date)] ${msg}\n" >> "$log_file";
    printf "\nFinished %s on $(date).\nLast exit code was: %d\n" "$SCRIPT" "$?"
  } >> "$log_file"
  report_stats
  set_red
  _line_fill | tee -a "$log_file"
  set_default
  exit "$2";
}


function _script_exit_log()
{
    # Script time
    readonly EXEC_END=$(date +%s)
    readonly EXEC_TIME=$((EXEC_END-EXEC_START))

    # Report Stats
    report_stats
    # Generage Exit message & log
    _goodbye_msg
    _debug_log "Exiting Script"
    printf "\nFinished %s in %d seconds, on %s.\nLast exit code was: %d\n" "$SCRIPT" "$EXEC_TIME" "$(date)" "$?" | tee -a "$log_file"
    _line_fill >> "$log_file"
    return 0
}


function _debug_log()
{
  local msg="$1"
  printf "[$(date)] ${_debug} $msg\n" >> "$log_file"
}


function _log_and_show()
{
  local msg="$1"
  printf "$msg\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}


function _log_and_warn()
{
  local msg="$1"
  set_red
  printf "$msg\n"
  set_default
  printf "[$(date)] $msg\n" >> "$log_file"
}


function _init_script_variables()
{
  # Function defines Script variables
  # Necessary variables used by the script are initialized here. This function
  # should be called first before choices are made, always.

  # Grabbing OS info
  distro_name=$(lsb_release -is | tr '[:upper:]' '[:lower:]')
  readonly VERSION=$(lsb_release -rs)
  readonly LONG_VERSION=$(lsb_release -ds)
  # Achtung: Do not set code_name as readonly!!
  code_name=$(lsb_release -cs)
  readonly architecture=$(dpkg --print-architecture)
  case "${architecture}" in
    amd64)          _debug_log "Architecture is 64 bit.";
                    readonly ARCH="amd64";
                    ;;
    i386)           _debug_log "Architecture is 32 bit.";
                    readonly ARCH="i386";
                    ;;
    armhf)          _debug_log "Running on ARM CPU with HW Floating point Processor";
                    readonly ARCH="armhf";
                    ;;
    arm64)           _debug_log "This is an ARM 64. Please be advised that not all reposirories support this arch.";
                    readonly ARCH="arm64";
                    ;;
    * )             set_red;
                    _log_and_show "${_error} Sorry! This architecture is not supported by this script!"
                    set_default;
                    _log_and_exit "Unsupported Architecture. $(architecture)" "11"
                    ;;
  esac

  # Get Hostname
  readonly CLIENT_NAME=$(hostname)
  # Generate a UUID
  readonly CLIENT_ID=$(cat /proc/sys/kernel/random/uuid)

  # etc sources list dir
  readonly SOURCES_FILE_DIR=/etc/apt/sources.list.d

  # Ping URL
  readonly PING_URL="www.google.com"


  #-------------------------- Release codenames --------------------------------------
  readonly code_name_latest_release="cosmic"
  readonly codename_previous_release="bionic"
  readonly codename_upcoming_release="disco"

  #============================ Switches/ bools & Vars ================================


  # Fix Repo not available for latest release
  bool_fix_repo_not_available_for_latest="false"


  # Allow repo fixes for Upcoming releases of ubuntu and its derivatives.
  bool_fix_repo_not_available_for_upcoming_release="false"

  # Checks for Version and Changelogs via APIs
  # Define API node endpoints

  bool_check_version="true"

  # Define API endpoint for version and config
  readonly metadata_endpoint="https://ae.prasadt.com/config"

  # Achtung!!
  # ========================================================================================= #

  # Purge not required packages
  # Default is false
  # Requires commad line option -d to be passed via command line otherwise it will not work.
  # Set this to true if you dont want to pass -d every time
  bool_purge_not_required_pkgs="false"

  # Say yes to all (No whiptail dialogs)
  # Default is false
  # Can be set to true and dialog boxes will be skipped if command line option -y is passed.
  # Set this to true if you dont want to pass -y every time
  bool_say_yes_to_all="false"

  # Keep Downloaded DEB packages
  bool_preserve_debs="false"

  # Default Stats Server name & Stats reporting flag
  #shellcheck disable=SC2034
  stats_node="https://stats.ae.prasadt.com/report"

  # Latest wine builds
  add_winehq_repo=false

  #Docker community edition
  add_docker_repo=false

  #Mendeley Desktop
  add_mendeley_repo=false

  #Spotify
  add_spotify_repo=false

  #InSync
  add_insync_repo=false

  #Google Cloud SDK
  add_googlecloud_repo=false

  #Signal
  add_signal_repo=false

  #Skype
  add_skype_repo=false

  #VS code
  add_vscode_repo=false

  #Google
  add_google_repo=false

  #Kubernetes
  add_kubernetes_repo=false

  #ROS
  add_ros_repo=false

  # Duo security
  add_duo_repo=false

  #
  # ================================================================================== #
  # Achtung!
  # Do not change any of the variables below this if you dont know what they do.
  # They are essential for correct working of the script or use unstable builds/repos.

  # Check Debian Flags
  bool_is_debian="false"

  # Check Signature
  #readonly bool_verify_gpg_signatures="true"


  #ROS RC repo
  # change this to true if you wish to use Release candidate repo for ROS
  ros_rc_repo="false"

  # latest WineHQ keys
  readonly use_latest_winehq_key="true"
}


function _init_print_basic_info()
{
  # This function logs and displays the Necessary details which helps in debugging.
  # Should be used after _init_script_variables function.
  _log_and_show "${_notice} Following details are recognised by the Script."
  _log_and_show "${_info} Hostname: ${CLIENT_NAME}"
  _log_and_show "${_info} UUID for Run: ${CLIENT_ID}"
  _log_and_show "${_info} Distro: ${distro_name}"
  _log_and_show "${_info} Version: ${VERSION}"
  _log_and_show "${_info} Code Name: ${code_name}"
  _log_and_show "${_info} Architecture: ${ARCH}"
  _log_and_show "${_info} Path for sources.list.d: ${SOURCES_FILE_DIR}"
  _log_and_show "${_version} ${REL_NAME} - ${REL_NUM}"

  #disable hist chars  so that I can print "!!"" properly
  histchars=
}


function delete_log_file()
{
  printf "${_deleting} log file...\n"
  rm "${log_file}" &> /dev/null \
  && printf "${_info} Deleting log file Successful.\n" "$log_file" \
  || printf "${_error} Deleting log file failed.\n" "$log_file"
  _line_fill;
  set_default;
  exit 0;

}


function  _add_timestamp_to_logs()
{
  # This function adds time stamp to logs without using external utilities
  # Output will be automatically written to $log_file
  # Arguments : 1
  # ARG -1: printf variable for formatting the log
  # Usage command | _add_timestamp_to_logs "$1"
  while IFS= read -r line; do printf "[$(date)] ${1} %s\n" "$line" &>> "$log_file"; done

}


function _check_dependencies()
{
  #Checks if commands in array are available.
  # Accepts one argument as array.
  local dependencies=("$@")
  local dependency_check_failed_count dep_res dependency
  dependency_check_failed_count=0;
  _log_and_show "${_info} Checking dependencies..."
  for dependency in "${dependencies[@]}"; do
   command -v "$dependency" > /dev/null
   dep_res=$?
   if [ "$dep_res" -eq 1 ]; then
     set_red;
     _log_and_show "${_error} $dependency is not installed!${NC}"
     set_default;
     dependency_check_failed_count=$((dependency_check_failed_count+1))
   fi
  done

  if [ "$dependency_check_failed_count" -gt 0 ]; then
    set_red
    _log_and_show "${_error} One or more dependencies not installed. Check logs or above message."
    _log_and_exit "${_error} Sorry! $SCRIPT cannot continue!" "1"
    set_default
  fi
}


function __disp_sig_check_passed()
{
  # Displays message after --verify proves that the GPG signatures match
  set_green
  printf "OK! Signature verified!\n"
  set_default
}


function __disp_sig_check_failed()
{
  # Displays failed GPG signature message
  set_red;
  printf "Oh No! Signature checks failed.\n"
  printf "File is either corrupt or has been modified.\n"
  set_default;
}


function verify_gpg_signature()
{
  # Verifies the file with its detached GPG signature.
  # Assumes that you already have public key in your keyring.
  # Assumes signature file is present at same localtion,
  # with same name but with .sig or .gpg or .asc extension.
  # Lets declare variables
  local sig_file
  # Checks if file is present
  if [ -f "${SCRIPT}.sig" ]; then
    sig_file="${SCRIPT}.sig"
  elif [ -f "${SCRIPT}.asc" ]; then
    sig_file="${SCRIPT}.asc"
  elif [ -f "${SCRIPT}.gpg" ]; then
    sig_file="${SCRIPT}.gpg"
  else
    printf "${YELLOW}Error! Signature file not found.${NC}\n"
    exit 51;
  fi

  # Check for signature files
  printf "Verifying GPG signature of file..\n"
  set_yellow
  printf "Signature File : ${sig_file}\n"
  printf "Data File      : $(basename $SCRIPT)\n"
  set_default
  # Checks for commands
  if command -v gpg > /dev/null; then
    if gpg --verify "${sig_file}" "${SCRIPT}" ; then
      __disp_sig_check_passed
    else
      __disp_sig_check_failed
      exit 50;
    fi
  elif command -v gpgv > /dev/null; then
    if gpgv --keyring "$HOME/.gnupg/pubring.kbx" "${sig_file}" "${SCRIPT}"; then
      __disp_sig_check_passed
    else
      __disp_sig_check_failed
      exit 50;
    fi
  else
    printf "Cannot perform verification. gpgv or gpg is not installed."
    printf "This action requires gnugpg/gnupg2 or gpgv package.\n"
    exit 1;
  fi


}


function report_stats()
{
  # Report anonymized stats about the script.
  # Following things are reported.
  # A UUID generated for each execution, (its random and is not persistant across runs)
  # sha-1 sum of Hostname, Total execution time, system architecture,
  # Distro name, feaure selected, last exit code, flags used, if Travis or Docker flags are true,
  # timezone and system language. Nothing else is collected. Period.
  # If you are feaking out, its a shellscript for heaven sake!! You can literally look into it
  # and check what's collected. Why if you ask? Just for fun and improvement of course!.
  # Data will be stored in AWS DynamoDB and/or Google Firebase.
  # Data will not be shared with any third party. Period. Only me or my team members will have access
  # to it. If you run a search query on google, it probably collects more data than me.
  # API endpoints may log public IP addresses (Github, Google and AWS). But they are not saved in the
  # database.
  # But I really really don't want to report stats because I Use it in "Top Secret" place under the rock.
  # Well, 1. You should not use this script! There are better tools like Chef and
  #          Ansible for huge deployments.
  #       2. Okay! Okay! just pass --no-stats or -S as an argument and be done ith it &
  #          the script WILL NOT "phone home".
  true
  if [[ "$ae_internal" == "true" ]]; then
    _debug_log "Martian Field is TRUE"
  fi
}


function _eol_message()
{
  # Display EOL Message and upgrade instruction URLs.
  # Arguments: 2
  # ARG 1: Release Name
  # ARG 2: EOL Date
  _log_and_warn "${_eol} This version of Ubuntu is no longer supported."
  _log_and_warn "${_notice} $1 reached EOL on $2."

   set_yellow;
  _log_and_warn "${_notice} Please use a supported version of Ubuntu."
  _log_and_show "${_info} Please visit the link below for information on how to upgrade."

  set_blue;
  _log_and_show "${_info} https://help.ubuntu.com/community/EOLUpgrades."
  _log_and_exit "EOL Release : $code_name" "12";
}


function _fix_ubuntu_derivatives()
{
  # Some Ubuntu based distributions use their own codename (Linux mint, Elementary)
  # Some repositories require that ubuntu codename is used.
  # This function fixes that for
  # Linux mint 17.X : Ubuntu 14.04 Trusty,
  # Linux mint 18.x : Ubuntu 16.04 Xenial,
  # Elementary OS Loki : Ubuntu 14.04 Trusty,
  # Elementary OS Freya and Juno : Ubuntu 16.04 Xenial
  # POP_OS! uses Ubuntu codenames (No need to apply fix)
  # If the release is not known this function exits the script for safety.

  _log_and_show "${_derivatives} Checking..."
  set_yellow;
  _debug_log "Variable code_name is : $code_name"
  case ${code_name} in
      qiana | rebecca | rafaela | rosa )    _log_and_show "${_linuxmint} Release is Linux mint 17.X."
                                            _log_and_show "${_notice} Setting additional repositoris to follow Ubuntu 14.04."
                                            code_name="trusty"
                                            _log_and_show "${_linuxmint} Changed codename to $code_name"
                                            ;;
      sarah | serena | sonya | sylvia )     _log_and_show "${_linuxmint} Release is Linux mint 18.X."
                                            _log_and_show "${_notice} Setting additional repositoris to follow Ubuntu 16.04."
                                            code_name="xenial";distro_name="ubuntu"
                                            _log_and_show "${_linuxmint} Changed codename to $code_name"
                                            ;;
      tara | tessa)                         _log_and_show "${_linuxmint} Release is Linux mint 19.X."
                                            _log_and_show "${_notice} Setting additional repositoris to follow Ubuntu 18.04."
                                            code_name="bionic";distro_name="ubuntu"
                                            _log_and_show "${_linuxmint} Changed codename to $code_name"
                                            ;;
      freya )                               _log_and_show "${_elementary} This release of Elementary OS is based on Ubuntu 14.04 Trusty."
                                            _log_and_show "${_notice} External repositories will use Ubuntu 14.04."
                                            code_name="trusty"
                                            _log_and_show "${_elementary} Changed codename to $code_name"
                                            ;;
      loki )                                _log_and_show "${_elementary} This release of Elementary OS is based on Ubuntu 16.04 Xenial."
                                            _log_and_show "${_notice} External repositories will use Ubuntu 16.04."
                                            code_name="xenial"
                                            _log_and_show "${_elementary} Changed codename to $code_name"
                                            ;;
      juno )                                _log_and_show "${_elementary} This release of Elementary OS is based on Ubuntu 18.04 Bionic."
                                            _log_and_show "${_notice} External repositories will use Ubuntu 18.04."
                                            code_name="bionic"
                                            _log_and_show "${_elementary} Changed codename to $code_name"
                                            ;;
      xenial | trusty | cosmic | bionic )   readonly bool_config_partner_repo="true"
                                            _log_and_show "${_info} Keeping the codename as: $code_name."
                                            ;;
      zesty )                               _eol_message "$code_name" "January 13th, 2018"
                                            ;;
      artful )                              _eol_message "$code_name" "July, 2018"
                                            ;;
      disco )                               readonly bool_config_partner_repo="true"
                                            set_magenta;
                                            _log_and_show "${_pre_release} This is Ubuntu 19.04 Disco Dingo"
                                            _log_and_show "${_pre_release} Please use --pre-release flag if you cannot add repos yet. There's no fix for PPAs."
                                            _log_and_show "${_warn} This is a pre-release of Ubuntu, which is in early stages of development. Use with caution!"
                                            _log_and_show "${_warn} Packages and PPAs might not work with this release!"
                                            ;;
      stretch | jessie | buster )           bool_is_debian="true";
                                            _log_and_show "${_notice} This is Debian. PPAs are disabled."
                                            ;;
      *)                                    set_red;
                                            _log_and_show "${_error} Unknown Distribution/Release."
                                            _log_and_show "${_notice} This Script is not designed to run on this ($code_name) distro/release."
                                            _script_exit_log;
                                            exit 16;
                                            ;;
  esac
  set_default;

}


function _test_internet_connection ()
{
  # Function to check internet connection
  _log_and_show "${_checking} Internet connection..."
  if wget --tries=3 --timeout=15 "$PING_URL" -O /tmp/ae/testinternet &>/dev/null 2>&1; then
    _log_and_show "${_checking} Connectivity"
    rm -f /tmp/ae/testinternet
  else
    _log_and_warn "${_oh_no} Booooooo! You are not connected to the Internet!. Please check your Internet connection and try again."
    rm -f /tmp/ae/testinternet || _debug_log "Failed to remove temp network connectivity resp file"
    _log_and_exit "${_error} No internet connection!" "14"
  fi
}


function _test_conflicting_apps ()
{
  # Function checks if any apps like syanptic aptitude are running.
  local lock
  _log_and_show "${_conflicts} Checking..."
  for lock in synaptic update-manager software-center apt-get dpkg aptitude
  do
    # shellcheck disable=SC2009
    if ps -U root -u root u | grep $lock | grep -v grep > /dev/null; then
      _log_and_exit "${_error} Installation won't work. Please close $lock first then try again." "15"
    else
      _debug_log "$lock not is running."
     fi
   done
   _log_and_show "${_conflicts} None detected."
}


function _set_custom_api_nodes ()
{

  # Set custom YAML
  if [ "$bool_use_yaml" == "true" ]; then

    # Custom Remote Config name as Query parameter name
    if [ "$bool_custom_remote_config_name" == "true" ]; then
     readonly remote_config_name="$custom_remote_config_name"
    else
     readonly remote_config_name="default"
    fi

    if [ "$bool_remote_yaml" == "true" ]; then
     readonly api_config_url="$url_remote_yaml?name=${remote_config_name}"
    elif [ "$bool_custom_config_file" == "true" ]; then
     _log_and_show "${_info} custom YAML file will be used."
    elif [ "$bool_use_default_yaml" == "true" ]; then
     _log_and_show "${_info} Using default YAML"
      readonly api_config_url="${metadata_endpoint}/default.yml"
    else
      _log_and_warn "${_error} No yaml file specified. To use default yaml use --use-default-yaml option."
      _log_and_exit "${_error} Script cannot continue. Exiting" "25"
    fi

  fi


  # Version, Config ang GPG signature URLS
  readonly api_version_url="${metadata_endpoint}/version.yml"
  _debug_log "Version Info URL is: ${api_version_url}"
  _log_and_show "${_info} Using Config YAML file at : $api_config_url"
}



function parse_yaml() {
  local yaml_file="${1}"
  local prefix="${2}"
  local s
  local w
  local fs

  s='[[:space:]]*'
  w='[a-zA-Z0-9_.-]*'
  fs="$(echo @|tr @ '\034')"

  (
    #shellcheck disable=SC1087
      sed -ne '/^--/s|--||g; s|\"|\\\"|g; s/\s*$//g;' \
          -e "/#.*[\"\']/!s| #.*||g; /^#/s|#.*||g;" \
          -e  "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
          -e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" |

      awk -F"$fs" '{
          indent = length($1)/2;
          if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
          vname[indent] = $2;
          for (i in vname) {if (i > indent) {delete vname[i]}}
              if (length($3) > 0) {
                  vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("__")}
                  printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
              }
          }' |

      sed -e 's/_=/+=/g' \
          -e '/\..*=/s|\.|_|' \
          -e '/\-.*=/s|\-|_|'

) < "$yaml_file"
}


function _get_remote_file()
{
  # Function to get remote file/response
  # exits script if it fails.
  # Accepts 2 arguments.
  # ARG 1: File name; Name of the local file the response or file should be saved as.
  # ARG 2: URL to the  file

  local file_name="${1}"
  local exit_status;
  local file_url="${2}"
  _debug_log "Remote URL is set to ${file_url}"

  if [ "$#" -eq 2 ]; then
    # Remote files
    wget -q "${file_url}" -O "$file_name" >> $"$log_file"
    exit_status="$?"

    _debug_log "Exit code from wget is : $exit_status"
    if [[ $exit_status -eq 0 ]]; then
      _debug_log "Successfully retrieved Config file."
    else
      _log_and_warn "${_error} Something went wrong while retrieving ${file_name}."
      _log_and_exit "${_error} Error Getiing file." "28"
    fi
  else
    _log_and_exit "${_error} Invalid number of arguments <_get_remote_file> Requires 2, got $#." "19"
  fi

}


function _version_checks ()
{
  # Checks if its running latest version.
  # Also suggest updating to latest version if current version is not latest,
  # Allows to deprecate old version as it can be suggested.
  # Check if Version Checks is enabled. (Default is enabled)
  if [ "$bool_check_version" == "true" ]; then
      _debug_log "Version Checks are enabled."
      _log_and_show "${_version} Checking for Updates..."
      if [ "$bool_custom_version_file" != "true" ]; then
        _debug_log "${_cfg} Using Remote Config file."
        _debug_log "Deleting old YAMLS"
        rm -f "/tmp/ae/api-version.yml" || _debug_log "Deleting old version YAML failed."
        readonly version_yaml_file="/tmp/ae/api-version.yml"
        # Get response/file
        _get_remote_file "$version_yaml_file" "$api_version_url"
      else
        _log_and_show "${_cfg} Using local Version file : $custom_version_file"
        readonly version_yaml_file="$custom_version_file"
      fi

      # Parse YAML to variables
      _debug_log "Parsing Version Config File"
      eval "$(parse_yaml "$version_yaml_file")"
      {
      _line_fill
      #declare -p
      _line_fill
      } >> "${log_file}"
      # Assign them to local variables as sometimes bash if does not handle array elements very well.
      local api_rel_num="${version__number[0]}"

      # Assign Statistics reporting flag and endpoint to Global variables.
      readonly api_report_endpoint="${stats__node[0]}"
      readonly api_report_usage="${stats__report[0]}"

      # Debug Info
      _debug_log "Version from API: ${api_rel_num}"
      _debug_log "Stats reporting is : ${api_report_usage}"
      _debug_log "Reporting endpoint is: ${api_report_endpoint}"

      # If release number is higher than one in the script throw error & ask to update.
      if [[ $api_rel_num -gt $REL_NUM ]]; then
        set_yellow;
        _log_and_show "${_version} A newer release is available.\n${_version} Please download latest release and try again."
        _log_and_show "${_version} You are running version ${REL_NAME} with version number ${REL_NUM}."
        echo "${version__name[0]}"
        echo "${api_rel_num}"
        _log_and_show "${_version} Latest available version is ${version__name[0]}-${api_rel_num}."
        _log_and_exit "${_info} You can disable version checks by passing\n${_version} --no-version-checks" "24"
        set_default;
      elif [[ $api_rel_num -eq $REL_NUM ]]; then
        _log_and_show "${_version} All Good! You are running the latest version of script."
      elif [[ $api_rel_num -lt $REL_NUM ]]; then
        set_yellow;
        _log_and_show "${_info} Hey Time traveler!\n${_version} You seem to be running a development version of script."
        _log_and_show "${_info} You are running version ${REL_NAME} - ${REL_NUM}."
        _log_and_show "${_info} Latest stable version is ${version__name[0]}-${api_rel_num}."
        set_default;
      fi

  # If version checks have been disabled
  else
    set_yellow
    _log_and_show "${_info} Version checks have been disabled."
    set_default
  fi
  #sleep 5

}


function _check_bool()
{
  # Function to check if config has valid values for bools.
  # Accepted values are true and false
  # If invalid, defaults to false.
  # Accepts global var and bool to check as arguments
  local g_var param_bool
  g_var="${1}"
  param_bool="${2}"
  _debug_log "Globar var is : $g_var, Param from cfg is $param_bool"
  case "${param_bool}" in
    true | True | TRUE | Yes | yes | YES | 1 )  declare -g ${g_var}="true"
                                                _debug_log "Variable : <$g_var> is set to true"
                                                ;;
    false | False | FALSE | No | no | NO | 0 )  declare -g ${g_var}="false"
                                                _debug_log "Variable : <$g_var> is set to false"
                                                ;;
    *)                                          declare -g ${g_var}="false"
                                                _log_and_show "${_warn} Invalid/empty value for param : $g_var."
                                                _log_and_show "${_warn} It can either be t[T]rue or f[F]alse."
                                                _log_and_show "${_warn} Setting $g_var to false"
                                                ;;
  esac
}


function _set_yaml_config()
{


  # Report usage flag
  if [ "$bool_report_stats" != "false" ]; then
    # If --no-stats is not used, bool_report_stats is not set. Lets set its value
    # from config.
    if [ "$api_report_usage" == "false" ]; then
      # Config file has disabled reporting set bool_report_stats to false.
      # Use readonly to prevent being overwritten.
      readonly bool_report_stats=false;
      _log_and_show "${_cfg} Usage reporting is disabled by server side flag."
    elif [ "$api_report_usage" == "true" ]; then
      # Config gile has set report stats to true. enable it.
      # Display endpoint for User info.
      # Use readonly to prevent being overwritten.
      readonly bool_report_stats="true";
      _log_and_show "${_cfg} Usage reporting is enabled."
      _log_and_show "${_cfg} Reporting endpoint is set as below\n${_api} ${api_report_endpoint}"
    else
      # If value is neither true or false, there is error in version config, exit the script.
      _log_and_exit "${_cfg} Configuration error. Expects boolean for stats.report key." "37"
    fi
  else
    # --no-stats option is used while running, which sets bool_report_stats to false
    _log_and_show "${_info} Usage reporting is disabled by User."
  fi

  # If yaml is set parse it.
  if [ "$bool_use_yaml" == "true" ]; then

    # Get and parse the file
    _log_and_show "${_info} Processing config..."
    if [ "$bool_custom_config_file" != "true" ]; then
      _log_and_show "${_cfg} Using Remote Config file."
      _debug_log "Deleting old YAMLS"
      rm -f "/tmp/ae/api-config.yml" || _debug_log "Deleting old version YAML failed."
      readonly config_yaml_file="/tmp/ae/api-config.yml"
      # Get response/file
      _get_remote_file "$config_yaml_file" "$api_config_url"
    else
      _log_and_show "${_cfg} Using local config file : $custom_config_file"
      readonly config_yaml_file="$custom_config_file"
    fi

    # Parse YAML to variables
    _debug_log "Parsing Config File "
    eval "$(parse_yaml "$config_yaml_file")"


    set_default;
    _line_fill;
    printf "${_table} %-20s | %-10s |\n" "Repository" "Enabled"
    _line_fill;
    set_blue;
    # Repo flags
    #################################################################################
    _check_bool "add_docker_repo" "${config__add_repo__docker[0]}"
    #add_docker_repo="${config__add_repo__docker[0]}"

    _check_bool "add_winehq_repo" "${config__add_repo__winehq[0]}"
    #add_winehq_repo="${config__add_repo__winehq[0]}"

    _check_bool "add_mendeley_repo" "${config__add_repo__mendeley[0]}"
    #add_mendeley_repo="${config__add_repo__mendeley[0]}"
    printf "${_cfg} %-20s | %-10s |\n" "Mendeley" "$add_mendeley_repo"

    _check_bool "add_googlecloud_repo" "${config__add_repo__googlecloud[0]}"
    #add_googlecloud_repo="${config__add_repo__googlecloud[0]}"

    _check_bool "add_spotify_repo" "${config__add_repo__spotify[0]}"
    #add_spotify_repo="${config__add_repo__spotify[0]}"

    _check_bool "add_skype_repo" "${config__add_repo__skype[0]}"
    #add_skype_repo="${config__add_repo__skype[0]}"

    _check_bool "add_vscode_repo" "${config__add_repo__vscode[0]}"
    #add_vscode_repo="${config__add_repo__vscode[0]}"

    _check_bool "add_insync_repo" "${config__add_repo__insync[0]}"
    #add_insync_repo="${config__add_repo__insync[0]}"

    _check_bool "add_signal_repo" "${config__add_repo__signal[0]}"
    #add_signal_repo="${config__add_repo__signal[0]}"

    _check_bool "add_google_repo" "${config__add_repo__google[0]}"
    #add_google_repo="${config__add_repo__google[0]}"

    _check_bool "add_kubernetes_repo" "${config__add_repo__kubernetes[0]}"
    #add_kubernetes_repo="${config__add_repo__kubernetes[0]}"

    # ROS
    _check_bool "add_ros_repo" "${config__add_repo__ros[0]}"

    # DUO
    _check_bool "add_duo_repo" "${config__add_repo__duo[0]}"

    # Other Script Flags

    #################################################################################
    # Purge Packages
    _check_bool "bool_purge_not_required_pkgs" "${config__flags__purge_enabled[0]}"
    #bool_purge_not_required_pkgs="${config__flags__purge_enabled[0]}"

    # Keep Debs
    _check_bool "bool_preserve_debs" "${config__flags__preserve_debs[0]}"
    #bool_preserve_debs="${config__flags__preserve_debs[0]}"

    # Yes
    _check_bool "bool_say_yes_to_all" "${config__flags__auto_yes[0]}"
    #bool_say_yes_to_all="${config__flags__auto_yes[0]}"

    # Uni-Mirror
    _check_bool "bool_use_uni_freiburg_mirror" "${config__flags__uni_freiburg_mirror[0]}"

    # Tasks Flags
    ##################################################################################

    #ae_task_update="${config__tasks__update[0]}"
    _check_bool "ae_task_update" "${config__tasks__update[0]}"

    #ae_task_upgrade="${config__tasks__upgrade[0]}"
    _check_bool "ae_task_upgrade" "${config__tasks__upgrade[0]}"

    #ae_task_repo="${config__tasks__repo[0]}"
    _check_bool "ae_task_repo" "${config__tasks__repo[0]}"

    #ae_task_ppa="${config__tasks__ppa[0]}"
    _check_bool "ae_task_ppa" "${config__tasks__ppa[0]}"

    #ae_task_apt="${config__tasks__apt[0]}"
    _check_bool "ae_task_apt" "${config__tasks__apt[0]}"

    #ae_task_debs="${config__tasks__debs[0]}"
    _check_bool "ae_task_debs" "${config__tasks__debs[0]}"

    #ae_task_purge="${config__tasks__purge[0]}"
    _check_bool "ae_task_purge" "${config__tasks__purge[0]}"

    #ae_task_pip2="${config__tasks__pip2[0]}"
    _check_bool "ae_task_pip2" "${config__tasks__pip2[0]}"

    #ae_task_pip3="${config__tasks__pip3[0]}"
    _check_bool "ae_task_pip3" "${config__tasks__pip3[0]}"

    #ae_task_conda="${config__tasks__pip3[0]}"
    _check_bool "ae_task_conda" "${config__tasks__conda[0]}"

    # Binaries Install
    _check_bool "ae_task_bin" "${config__tasks__binaries[0]}"

    if [ "${bool_hide_config}" != "true" ]; then
      printf "${_cfg} %-20s | %-10s |\n" "Docker CE" "$add_docker_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Wine-HQ" "$add_winehq_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Google Cloud SDK" "$add_googlecloud_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Spotify" "$add_spotify_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Skype" "$add_skype_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Visual Studio Code" "$add_vscode_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Insync" "$add_insync_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Signal for Desktop" "$add_signal_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Google Chrome & Earth" "$add_google_repo"
      printf "${_cfg} %-20s | %-10s |\n" "Kubernetes" "$add_kubernetes_repo"
      printf "${_cfg} %-20s | %-10s |\n" "ROS" "$add_ros_repo"
      set_default;
      _line_fill;
      printf "${_table} %-20s | %-10s |\n" "Other Flags" "Config"
      _line_fill;
      set_blue
      printf "${_cfg} %-20s | %-10s |\n" "Purge Enabled" "$bool_purge_not_required_pkgs"
      printf "${_cfg} %-20s | %-10s |\n" "Keep DEBs/APT cache" "$bool_preserve_debs"
      printf "${_cfg} %-20s | %-10s |\n" "Dont confirm" "$bool_say_yes_to_all"
      printf "${_cfg} %-20s | %-10s |\n" "Uni-Freiburg Mirror" "$bool_use_uni_freiburg_mirror"
      _line_fill;

      # Only display tasks column when autopilot = true is set.
      if [ "$AUTOPILOT" == "true" ]; then
        printf "${_table} %-20s | %-10s |\n" "Task" "Config"
        _line_fill;
        set_magenta
        printf "${_rtasks} %-20s | %-10s |\n" "Update" "$ae_task_update"
        printf "${_rtasks} %-20s | %-10s |\n" "Upgrade" "$ae_task_upgrade"
        printf "${_rtasks} %-20s | %-10s |\n" "Add Repos" "$ae_task_repo"
        printf "${_rtasks} %-20s | %-10s |\n" "Add PPA" "$ae_task_ppa"
        printf "${_rtasks} %-20s | %-10s |\n" "APT packages" "$ae_task_apt"
        printf "${_rtasks} %-20s | %-10s |\n" "DEB packages" "$ae_task_debs"
        printf "${_rtasks} %-20s | %-10s |\n" "Purge packages" "$ae_task_purge"
        printf "${_rtasks} %-20s | %-10s |\n" "Python 2 Modules" "$ae_task_pip2"
        printf "${_rtasks} %-20s | %-10s |\n" "Python 3 Modules" "$ae_task_pip3"
        printf "${_rtasks} %-20s | %-10s |\n" "Conda Modules" "$ae_task_conda"
        printf "${_rtasks} %-20s | %-10s |\n" "Static Binaries" "$ae_task_bin"
        set_default;
        _line_fill;
      fi
      set_default
    else
      _log_and_show "${_cfg} Configuration data is hidden."
      _log_and_show "${_cfg} Please check the logfile or dont use --hide-config to display configuration."
      {
        printf "${_cfg} %-20s | %-10s |\n" "Docker CE" "$add_docker_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Wine-HQ" "$add_winehq_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Google Cloud SDK" "$add_googlecloud_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Spotify" "$add_spotify_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Skype" "$add_skype_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Visual Studio Code" "$add_vscode_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Insync" "$add_insync_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Signal for Desktop" "$add_signal_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Google Chrome & Earth" "$add_google_repo"
        printf "${_cfg} %-20s | %-10s |\n" "Kubernetes" "$add_kubernetes_repo"
        printf "${_cfg} %-20s | %-10s |\n" "ROS" "$add_ros_repo"
        printf "${_table} %-20s | %-10s |\n" "Other Flags" "Config"
        _line_fill;
        printf "${_cfg} %-20s | %-10s |\n" "Purge Enabled" "$bool_purge_not_required_pkgs"
        printf "${_cfg} %-20s | %-10s |\n" "Keep DEBs/APT cache" "$bool_preserve_debs"
        printf "${_cfg} %-20s | %-10s |\n" "Dont confirm" "$bool_say_yes_to_all"
        printf "${_cfg} %-20s | %-10s |\n" "Use Uni-Freiburg Mirror" "$bool_use_uni_freiburg_mirror"
        _line_fill;
        printf "${_table} %-20s | %-10s |\n" "Task" "Config"
        printf "${_rtasks} %-20s | %-10s |\n" "Update" "$ae_task_update"
        printf "${_rtasks} %-20s | %-10s |\n" "Upgrade" "$ae_task_upgrade"
        printf "${_rtasks} %-20s | %-10s |\n" "Add Repos" "$ae_task_repo"
        printf "${_rtasks} %-20s | %-10s |\n" "Add PPA" "$ae_task_ppa"
        printf "${_rtasks} %-20s | %-10s |\n" "APT packages" "$ae_task_apt"
        printf "${_rtasks} %-20s | %-10s |\n" "DEB packages" "$ae_task_debs"
        printf "${_rtasks} %-20s | %-10s |\n" "Purge packages" "$ae_task_purge"
        printf "${_rtasks} %-20s | %-10s |\n" "Python 2 Modules" "$ae_task_pip2"
        printf "${_rtasks} %-20s | %-10s |\n" "Python 3 Modules" "$ae_task_pip3"
        printf "${_rtasks} %-20s | %-10s |\n" "Conda Modules" "$ae_task_conda"
        printf "${_rtasks} %-20s | %-10s |\n" "Static Binaries" "$ae_task_bin"
        _line_fill;
        _line_fill;
      } >> "${log_file}"
    fi
    #################################################################################
    #                              Parse Arrays
    #################################################################################
    # Config file YAML has arrays of apt packages.
    # We need to parse apt packages, ppa's, deb packages, python modules listed in yaml
    # to bash arrays.

    #--------------------------------------------------------------------------------
    #                               APT Lists
    #--------------------------------------------------------------------------------
    # There are Seven lists under key config.install.apt.[mentioned from 1-7]
    # 1. administration : Contains Administrative packages
    # 2. security       : contains Security related tools and packages
    # 3. productivity   : Office tools, writing tools, LateX, document tools and other
    #                     productivity tools, Email clients, browsers, IM clients etc.
    #                   : Example : LateX, TeXStudio, Libre office, pandoc empathy, Thunderbird
    # 4. Multimedia     : Multimedia tools like media players, audio converters and playes etc.
    # 5. development    : IDEs [Spyder, Jetbeans etc], languages [go, python, ruby, rust, java etc],
    #                   : Containers [docker lxc rkt etc], Python libraries, compilers [gcc, clang]
    #                   : SDKs [AWS SDK, Coogle Cloud SDK, open-jdk, Tensor Flow], headers
    #                   : and libraries[ocl-icd-dev],
    #                   : Anything related to development and *-dev or *-devl packages.
    # 6. other          : Everything which doesnot fit in the above categories.
    #                   : Themes, Tools, Utilities like htop etc.
    # 7. External       : Any packages which are provided by ppas, or repositories not present in
    #                   : base *buntu distribution. There's a possibility that the repository might not
    #                   : be added or may be unavailable or offline. So Keeping the list seperate from
    #                   : others packages minimizes errors if there are any.
    # This classification is only for ease of use and need not be strictly followed. You can put
    # vlc package in 'security', it will still install fine. This classification helps
    # while writing configs and editing them. Its advised to follow it if your configs
    # tend to get to couple of hundreds of lines. Also YAML file should be a valid YAML.

    #--------------------------------------------------------------------------------
    #                             Special list - Purge list
    #--------------------------------------------------------------------------------
    # There is a special package list under key, config.purge or purge.list, which contains
    # list of apt packages to be purged from the system if present.

    #--------------------------------------------------------------------------------
    #                             Special list - Purge list
    #--------------------------------------------------------------------------------
    # There is a special package list under key, config.purge, which contains list of apt packages to be
    # purges from the system if present.

    # Lets get em, shall we?

    # Copy package list
    declare -gar parsed_purge_packages=("${config__purge_[@]}")
    declare -gar parsed_administration_packages=("${config__install__apt__administration_[@]}")
    declare -gar parsed_secutity_packages=("${config__install__apt__security_[@]}")
    declare -gar parsed_productivity_packages=("${config__install__apt__productivity_[@]}")
    declare -gar parsed_multimedia_packages=("${config__install__apt__multimedia_[@]}")
    declare -gar parsed_development_packages=("${config__install__apt__development_[@]}")
    declare -gar parsed_other_packages=("${config__install__apt__other_[@]}")
    declare -gar parsed_external_packages=("${config__install__apt__external_[@]}")

    #--------------------------------------------------------------------------------
    #                             PPA Lists
    #--------------------------------------------------------------------------------
    # Config file contains list of PPAs to be added under key
    # config.ppa
    declare -gar parsed_ppa_list=("${config__ppa_[@]}")

    #--------------------------------------------------------------------------------
    #                             Debian packages
    #--------------------------------------------------------------------------------
    # Config file contains list of DEB packages to be downloaded & installed under key
    # config.install.debian_packages
    # The configuration is not simple URL its csv. <URL to Deb file>,<Name of the Package>
    # This is for compatiblity reasons
    declare -gar parsed_deb_files_list=("${config__install__debian_packages_[@]}")

    #--------------------------------------------------------------------------------
    #                             Python Modules
    #--------------------------------------------------------------------------------
    # There are two keys under config.install.python(2/3) which contain Python 2 and Python 3
    # Modules respectively. Please donot mix python 2 Modules with Python 3.

    declare -gar parsed_pip2_packages=("${config__install__python2_[@]}")
    declare -gar parsed_pip3_packages=("${config__install__python3_[@]}")
    declare -gar parsed_conda_packages=("${config__install__conda__packages_[@]}")
    declare -gar parsed_bin_packages=("${config__install__binaries_[@]}")
 fi

  {
  _line_fill
#  declare -p
  _line_fill
  } >> "${log_file}"

}


function _set_list_config()
{
   # If --local or --list option is used then we dont need to fetch Configs
  # We need to just parse the .list files in data.Flags will be local and can be alterd via options or editing the
  # Script itself.
  if [ "$bool_use_lists" == "true" ]; then
    _log_and_show "${_cfg} Local Flags and Configs are preferred."
    _log_and_show "${_cfg} Parsing local lists..."

    # Latest wine builds
    add_winehq_repo=true

    #Docker community edition
    add_docker_repo=true

    #Mendeley Desktop
    add_mendeley_repo=false

    #Spotify
    add_spotify_repo=true

    #InSync
    add_insync_repo=true

    #Google Cloud SDK
    add_googlecloud_repo=true

    #Signal
    add_signal_repo=true

    #Skype
    add_skype_repo=true

    #VS code
    add_vscode_repo=true

    #Google
    add_google_repo=true

    #Kubernetes
    add_kubernetes_repo=false

    #ROS
    add_ros_repo=false

    #DUO
    add_duo_repo=false

    ae_task_update="true"
    ae_task_upgrade="true"
    ae_task_repo="true"
    ae_task_ppa="true"
    ae_task_apt="true"
    ae_task_debs="true"
    ae_task_pip2="true"
    ae_task_pip3="true"
    ae_task_conda="true"
    ae_task_purge="true"
    ae_task_bin="true"

    #shellcheck disable=SC2034
    local list_file line
    readonly local lists=(
                          administration.list
                          security.list
                          productivity.list
                          multimedia.list
                          development.list
                          others.list
                          external.list
                          ppa.list
                          deb.list
                          purge.list
                          pip.list
                          pip3.list
                          bin.list
                        )

    for list in "${lists[@]}"; do
      declare -a tmp_arr
      _debug_log "Processing List : $list"
      if [ -f "${dir}/data/${list}" ]; then
        touch /tmp/ae/cleaned.clist && truncate -s 0 /tmp/ae/cleaned.clist
        # Clean comments & empty spaces
        grep -v -e ^% -e ^\# -e '^[[:space:]]*$' "${dir}/data/${list}" > /tmp/ae/cleaned.clist
        _debug_log "Cleaned List is below"
        _line_fill >> "${log_file}"
        # shellcheck disable=SC2002
        cat /tmp/ae/cleaned.clist | _add_timestamp_to_logs "${_list}"
        # Read line by line & Parse array
        i=0;
        while IFS= read -r line; do
          tmp_arr[i]="${line}" && ((++i))
        done < /tmp/ae/cleaned.clist
        _debug_log "Parsed $list"
        case "${list}" in
          administration.list)  declare -gar parsed_administration_packages=("${tmp_arr[@]}");;
          security.list)        declare -gar parsed_secutity_packages=("${tmp_arr[@]}");;
          productivity.list)    declare -gar parsed_productivity_packages=("${tmp_arr[@]}");;
          multimedia.list)      declare -gar parsed_multimedia_packages=("${tmp_arr[@]}");;
          others.list)          declare -gar parsed_other_packages=("${tmp_arr[@]}");;
          development.list)     declare -gar parsed_development_packages=("${tmp_arr[@]}");;
          external.list)        declare -gar parsed_external_packages=("${tmp_arr[@]}");;
          ppa.list)             declare -gar parsed_ppa_list=("${tmp_arr[@]}");;
          deb.list)             declare -gar parsed_deb_files_list=("${tmp_arr[@]}");;
          purge.list)           declare -gar parsed_purge_packages=("${tmp_arr[@]}");;
          pip.list)             declare -gar parsed_pip2_packages=("${tmp_arr[@]}");;
          pip3.list)            declare -gar parsed_pip3_packages=("${tmp_arr[@]}");;
          bin.list)             declare -gar parsed_bin_packages=("${tmp_arr[@]}");;
        esac
        # Unset local array
      else
        set_yellow
        _log_and_show "${_warn} $list not found under data directory."
        set_default
      fi
      unset tmp_arr || _log_and_exit "Unable to unset array" "40"
    done

  fi
}


function _show_confirmation_dialog_for_tasks()
{
  # Function to confirm whether action selected should be perfromed or not.
  # Accepts 3 arguments
  # ARG-1 Name of the task/function selected
  # ARG-2 Message to be displayed in confirmation box
  # ARG-3 name of the function to execute
  # Depends on whiptail
  # To overide and say yes to all dialog pass -y as command line option while running the script.
  local name_of_task="${1}" #Name of the task to be perfromed
  local confirm_msg="${2}" #Message shown in Confirmation dialogue
  local exec_function="${3}" #Function to run if user selected yes
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  export COLUMNS LINES
  if [ "$bool_say_yes_to_all" != "true" ]; then
    _debug_log "Confirmation dialog is Necessary to get user approval to make changes for: $exec_function."
    # shellcheck disable=SC2086
    if (whiptail  --title "$name_of_task" --yesno "$confirm_msg" $LINES $COLUMNS $(( LINES - 12 ))) then
        _debug_log "User selected yes, Proceed with $name_of_task"
        # execute the function
        _debug_log "Executing: $exec_function"
        $exec_function
    else
        _debug_log "Selected No for $name_of_task , Returning to Main menu."
        _process_menu;
    fi
  elif [ "$bool_say_yes_to_all" = "true" ]; then
    _debug_log "Yes to all: No confirm dialogs to be displayed."
    _debug_log "Executing: $exec_function"
    $exec_function;
  else
    _debug_log "Illegal value for bool_say_yes_to_all."
  fi
  unset exec_function
}


function _clean_apt_cache()
{
  # Function to clean apt package cache. Takes care of -k flag in all the installs.
  # Honor -k flag
  # Delete DEBs
  _debug_log "Cleaning APT packages..."
  if [ "$bool_preserve_debs" != "true" ];then
    _log_and_show "${_deleting} APT Cached Packages"
    apt-get -q clean | _add_timestamp_to_logs "${_apt_logs}"
  else
    _debug_log "Keeping cached APT Packages because -k flag is set."
  fi

}


function _install_dependencies()
{
  # Install packages mentioned in the arguments.
  # If installation fails exit the script.
  # ARG 1: Packages in quote seperated by space.
  local packages=("$@")
  _debug_log "Installing Packages"
  {
    _debug_log "Following packages will be installed\n"
    _debug_log "[$(date)] ${_array} %s\n" "${packages[@]}"
  } >> "${log_file}"
  # Check if array is empty
  if [[ ${#packages[@]} -eq 0 ]]; then
    set_yellow;
    _log_and_exit "${_error} Package array is empty!" "19"
  else
    apt-get -q -y install "${packages[@]}" 2>&1 | _add_timestamp_to_logs "${_apt_logs}"  \
    || _log_and_exit "${_error} Failed to install dependencies. Script cannot continue!!" "21"

    exit_status=$?
    if [ $exit_status -eq 0 ]; then
       _log_and_show "${_installed} dependency packages."
    else
      _log_and_warn "${_oh_no} Something went wrong while installing dependencies."
      _log_and_exit "${_notice} Please see the log file for more details." "21"
    fi
  _clean_apt_cache
  fi
}


function _install_pre_requisites()
{
  # This function installs required packages for adding apt repositories
  # These should be present in your base ubuntu instal. If not present then, this function
  # will install them.
  # Following are the packages installed by this function:
  # linux-image-extra-<>, apt-transport-https, ca-certificates,
  # curl, software-properties-common
  local pre_requisite_packages=(apt-transport-https ca-certificates curl software-properties-common gpgv)
  _log_and_show "${_installing} Necessary dependencies..."
  _debug_log "${_installing} apt-transport-https, ca-certificates, curl, software-properties-common gnugpg"
  _install_dependencies "${pre_requisite_packages[@]}"

}


function _fix_repo_not_available()
{
  # If repository is not available for latest ubuntu release, this uses last stable release
  # (may not be LTS) for adding repository
  if [ "$bool_fix_repo_not_available_for_latest" == "true" ]; then
    # Only do this on latest releases
    if [ "$code_name" == "$code_name_latest_release" ]; then
      _debug_log "Sometimes repositories are not available for latest ubuntu release.\
      \nUsing last known stable release: $code_name_latest_release."
      printf "${YELLOW}${_new_release} Using repositories from an older release: $codename_previous_release is being used.\n"
      printf "${YELLOW}${_new_release} You need to modify this in Software and updates when it becomes available for ${code_name_latest_release}.\n${NC}"
      code_name="$codename_previous_release"
    else
      _debug_log "This Release/Distro does not support this flag. --fix will be ignored."
    fi
  else
    _debug_log "Feature fix_repo_not_available is disabled."
fi
}


function _fix_repo_not_available_upcoming_release()
{
  # If repository is not available for upcoming ubuntu release, this uses last stable release or one release before that
  # Aka if the pre-release release is 18.04 it might use 17.04 (Only for first month or two) till repositories become available for the release 17.10)
  # (may not be LTS) for adding repository.

  # check for fix-pre-release flag
  if [ "$bool_fix_repo_not_available_for_upcoming_release" == "true" ]; then

    # Only do this on upcoming-release
    if [ "$code_name" == "$codename_upcoming_release" ]; then
      _log_and_show "${_pre_release} Previously available repositories from an older release is being used."
      printf "${_pre_release}You need to modify this in Software and Updates when it \
              becomes available for ${codename_upcoming_release}${NC}\n"
        # If the repositories are  not available for latest stable release as well, go back a release.
        # Eg. If the pre-release is 18.04 and the repo is not available for 17.10 as well, we use 17.04 repositories.
        # Usually happens in first few days of development cycle of 18.04.
        if [ "$bool_fix_repo_not_available_for_latest" == "true" ]; then
          # We need to use repositories for previous stable release.
          _log_and_show "${_pre_release} Both falgs for --pre-release and -fix are set. Using codename: $codename_previous_release"
          code_name="$codename_previous_release"
        else
          # No need to apply fix for latest release, We can use latest stable release repositories
          _log_and_show "${_pre_release} Using repositories for current stable release: $code_name_latest_release"
          code_name="$code_name_latest_release"
        fi
    else
        _debug_log "This Release/Distro does not support this option. Flag --pre-release will be ignored."
    fi
  else
    set_yellow
    _debug_log "Feature fix_repo_not_available_upcoming_release is disabled."
    set_default
fi
}


function add_ppas()
{
  # Function to add ppa by reading ppas from ppa.list of from YAML key config.ppa
  # List/Config file should contain ppas in following format
  # ppa:ppa:<author>/<ppa> for example, ppa:mozillateam/firefox-nex for adding firefox next/Beta PPA
  _debug_log "Adding PPA Fucntion"
  local index;
  # Function Reads the file ${dir}/data/ppa.index and adds the ppa one by one.
  # Install dependencies required
  if [ "$bool_is_debian" != "true" ]; then
    _install_pre_requisites;

      for index in "${parsed_ppa_list[@]}"; do
            _log_and_show "${_ppa} $index"
            # Check for empty lines
            if [ "$index" == "" ]; then
              _log_and_show "${_ppa} Found and empty entry Moving on to next.."
              continue
            fi
            if add-apt-repository -y "$index" 2>&1 | _add_timestamp_to_logs "${_ppa_logs}" ; then
              set_green
              _log_and_show "${_ppa} Success!"
              set_default
            else
              set_yellow
              _log_and_show "${_ppa} Some Error occured while adding $index. Ignoring and moving on.\n"
              set_default
            fi
        done
  else
    set_yellow;
    _log_and_show "${_ppa} This is Debian. PPAs are not available."
    set_default;
  fi
  _line_fill >> "$log_file"
}


function add_repositories()
{
  # This function adds repositories for several apps like
  # Google Chrome, Spotify, Google Cloud SDK, GCSFUSE(Part of google cloud),
  # Skype, Docker, Skype, Microsoft Visual Studio Code, Google Earth, Insync client, WineHQ etc
  # WARNING: Some repositories might not support latest version of Ubuntu.

  local CLOUD_SDK_REPO
  local GCSFUSE_REPO
  local exit_status
  # install dependencies required
  _install_pre_requisites;
  # if repository is not available for latest ubuntu release, use previous release
  # Be careful, things might not be compatible
  _fix_repo_not_available_upcoming_release;
  _fix_repo_not_available;
  _debug_log "Adding External Repositories"

  # Add Google Chrome and Google Earth
  if [ "$add_google_repo" == "true" ]; then
    _log_and_show "${_repo} Google repositories"
    if [ "$ARCH" == "amd64" ]; then
        _debug_log "Adding Google package signing Key"
      wget -q  https://dl.google.com/linux/linux_signing_key.pub -O /tmp/ae/linux_signing_key.pub >> $"$log_file"
      _debug_log "Adding Google key to trusted keys list"
      apt-key add /tmp/ae/linux_signing_key.pub 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_and_warn "${_error} Adding trusted keys for Google failed."

      _log_and_show "${_repo} Google Chrome repository"
      echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main #Google-Chrome" > ${SOURCES_FILE_DIR}/google-chrome.list \
      || _log_and_warn "${_error} Adding Google Chrome Repository failed"

      _log_and_show "${_repo} Google Earth repository"

      echo "deb [arch=amd64] http://dl.google.com/linux/earth/deb/ stable main #Google-Earth" > ${SOURCES_FILE_DIR}/google-earth.list \
      || _log_and_warn "${_error} Adding Google Chrome repository failed"

    else
      _log_and_warn "Architecture: $ARCH is not supported for Chrome. Please use Chromium"
    fi
  else
    _log_and_show "${_repo} Chrome repository is set to false. Skipping."
  fi


  # Spotify client
  if [ "$add_spotify_repo" == "true" ]; then
    _log_and_show "${_repo} Spotify repository"
    _debug_log "Adding Spotify keys"
    apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 931FF8E79F0876134EDDBDCCA87FF9DF48BF1C90  2>&1 \
    |_add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_error} Adding Spotify repository failed"

    echo "deb http://repository.spotify.com stable non-free #Spotify" > ${SOURCES_FILE_DIR}/spotify.list \
    || _log_and_warn "${_error} Adding Spotify Repository Failed"
  else
    _log_and_show "${_repo} Spotify repository is set to false. Skipping."
  fi

  # Insync
  if [ "$add_insync_repo" == "true" ] && [ "$bool_is_debian" != "true" ]; then
    _log_and_show "${_repo} Insync repository"
    _debug_log "Adding Insync keys"
    apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys ACCAF35C  2>&1 \
    | _add_timestamp_to_logs "${_apt_key_logs}" \
    || _log_and_warn "${_error} Adding Insync Repository failed"

    echo "deb http://apt.insynchq.com/${distro_name} $code_name non-free contrib #Insync-Client" > ${SOURCES_FILE_DIR}/insync.list \
    || _log_and_warn "${_error} Adding Insync Repository failed"

  elif [ "$add_insync_repo" == "true" ] && [ "$bool_is_debian" == "true" ]; then
    set_yellow;
    _log_and_warn "${_whoops} Unfortunately InSync repositoris are not supported on Debian."
    _log_and_warn "${_info} Please use debfile instead of repositoris."
    set_blue;
    _log_and_show "${_info} Visit https://ae.prasadt.com/tasks/#install-debian-package-archives-deb-files"
    set_default;
  else
    _log_and_show "${_repo} Insync repository is set to false. Skipping."
  fi

  # Google Cloud SDK and GCS-FUSE
  if [ "$add_googlecloud_repo" == "true" ]; then
    CLOUD_SDK_REPO="cloud-sdk-${code_name}"
    GCSFUSE_REPO="gcsfuse-${code_name}"
    _log_and_show "${_repo} Adding GCP Repositories"
    _debug_log "Adding Google-Cloud repository sigining key"
    wget -q https://packages.cloud.google.com/apt/doc/apt-key.gpg -O /tmp/ae/googlecloud.gpg >> "$log_file"
    apt-key add /tmp/ae/googlecloud.gpg 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"
    _log_and_show "${_repo} Google-Cloud-SDK repository"
    echo "deb http://packages.cloud.google.com/apt $CLOUD_SDK_REPO main #Google-Cloud-SDK" > ${SOURCES_FILE_DIR}/google-cloud-sdk.list  \
    || _log_and_warn "${_error} Adding GCSFUSE Repository failed"

    _log_and_show "${_repo} GCSFUSE repository"
    echo "deb http://packages.cloud.google.com/apt $GCSFUSE_REPO main #GCSFUSE" > ${SOURCES_FILE_DIR}/gcsfuse.list  \
    || _log_and_warn "${_error} Adding Google Cloud SDK Repository failed"

  else
    _log_and_show "${_repo} Google Cloud SDK repository is set to false. Skipping."
  fi

  #AWS
  # Handled by pip

  #Wine HQ
  if [ "$add_winehq_repo" == "true" ]; then
    _log_and_show "${_repo} WineHQ repository"
    _debug_log "Getting WineHQ repository Key"
    if [[ "$use_latest_winehq_key" == "true" ]]; then
      _log_and_show "${_repo} WineHQ keys were changed recently, using them."
      wget -q https://dl.winehq.org/wine-builds/winehq.key -O /tmp/ae/wine-hq-sigining-key.key >> "$log_file"  2>&1
    else
      # This is old key. the new key was added on 19th Dec 2018
      wget -q https://dl.winehq.org/wine-builds/Release.key -O /tmp/ae/wine-hq-sigining-key.key >> "$log_file"  2>&1
    fi
    _debug_log "Adding WineHQ key"
    apt-key add /tmp/ae/wine-hq-sigining-key.key 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" \
    || _log_and_warn "${_error} Adding WineHQ keys failed"
    _debug_log "Adding WineHQ repository"
    echo "deb https://dl.winehq.org/wine-builds/${distro_name}/ ${code_name} main #WineHQ" > ${SOURCES_FILE_DIR}/winehq.list \
    || _log_and_warn "${_error} Adding WineHQ repository failed"
  else
    _log_and_show "${_repo} WineHQ repository is set to false. Skipping."
  fi

  # Docker CE
  if [ "$add_docker_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ] || [ "$ARCH" == "armhf" ]; then
      _log_and_show "${_repo} Docker-CE repository"
      _debug_log "Getting Docker-CE repository Key"
      wget -q https://download.docker.com/linux/"${distro_name}"/gpg -O /tmp/ae/docker-key.gpg >> "$log_file"  2>&1
      _debug_log "Adding Docker repository key"
      apt-key add /tmp/ae/docker-key.gpg 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_and_warn "${_error} Adding Docker-CE keys failed"
      _debug_log "${_repo} Docker-CE"
      echo "deb [arch=$ARCH] https://download.docker.com/linux/${distro_name}  ${code_name} stable #Docker-Community-Edition" > ${SOURCES_FILE_DIR}/docker.list \
      || _log_and_warn "${_error} Adding Docker-CE repository failed"
    else
      _log_and_warn "${_error} Architecture not supported!. Please use docker.io package from your distro."
    fi
  else
    _debug_log "Adding Docekr-CE repository is set to false. Skipping."
  fi

  # Skype
  if [ "$add_skype_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ] || [ "$ARCH" == "i386" ]; then
      _log_and_show "${_repo} Skype for Linux repository"
      _debug_log "Getting Skype repository key"
      wget -q https://repo.skype.com/data/SKYPE-GPG-KEY -O /tmp/ae/skype-linux-key.gpg >> "$log_file"
      _debug_log "Adding Skype keys to trusted list"
      apt-key add /tmp/ae/skype-linux-key.gpg 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_and_warn "${_error} Adding Skype for linux key failed"
      echo "deb [arch=$ARCH] https://repo.skype.com/deb stable main #Skype" > $SOURCES_FILE_DIR/skype-stable.list \
      || _log_and_warn "${_error} Adding Skype for linux repository failed"
    else
      _log_and_warn "${_error} Skype doesnot support this architecture"
    fi
  else
    _log_and_show "${_repo} Skype repository is set to false. Skipping."
  fi

  # ROS
  # Arch support varies on distro so lot of ugly elifs.
  # Packges share same name across RC and Stable. so its not possible to
  # use both RC(ros-shadow-fixed and ros) repos at the same time.
  # rusty will reach EOL soon, ITs not supoorted and its complicated due to
  # http://wiki.ros.org/indigo/Installation/Ubuntu
  # Dependency issues which might pop up.
  ros_arch_supported="false"


  if [ "$add_ros_repo" == "true" ]; then

    # Unstable/RC repos
    if [[ $ros_rc_repo == "true" ]]; then
      _log_and_warn "${_repo} Using ROS Release candidate [ROS Shadow Fixed] repositories"
      ros_repo_path="ros-shadow-fixed"
    else
      _log_and_show "${_repo} Using stable version of ROS"
      ros_repo_path="ros"
    fi

    # Distro/Version/Arch checks
    if [[ $distro_name == "ubuntu" ]] || [[ $distro_name == "linuxmint" ]] ; then
        # Check architectures
        # Bionic
        if [[ $code_name == "bionic" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] || [[ $ARCH == "armhf" ]]; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Bionic/$ARCH"
          fi

        elif [[ $code_name == "xenial" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] || [[ $ARCH == "armhf" ]] || [[ $ARCH == "i386" ]]; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Xenial/$ARCH"
          fi
        fi
    fi #ubuntu

    if [ "$distro_name" == "debian" ]; then
        # Check architectures
        # stretch | jessie
        if [[ $code_name == "stretch" ]] || [[ $code_name == "jessie" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] ; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Debian ${code_name}/$ARCH"
          fi
        fi
    fi #debian

    if [[ $ros_arch_supported == "true" ]]; then
      _log_and_show "${_repo} ROS is Supported on this distro/ARCH : ${code_name}/${ARCH}"
      _debug_log "Adding ROS repo key..."
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
       || _log_and_warn "${_error} Adding ROS repository key failed!"

       if [[ $bool_use_uni_freiburg_mirror == "true" ]] && [[ $distro_name == "ubuntu" ]]; then
         _log_and_warn "Using Uni-Freiburg Mirror! This mirror might not be upto date with primary ROS repository!."
         _log_and_warn "You may need authentication or have to be inside Uni-Freiburg network!"
         echo "deb http://packages.ros.org.ros.informatik.uni-freiburg.de/${ros_repo_path}/ubuntu ${code_name} main #ROS-Repo-Uni-Freiburg" > $SOURCES_FILE_DIR/ros-latest.list \
         || _log_and_warn "${_error} Adding ROS [Uni-Freiburg] repository failed!"
      else
        echo "deb http://packages.ros.org/${ros_repo_path}/ubuntu ${code_name} main #ROS-Repo" > $SOURCES_FILE_DIR/ros-latest.list \
        || _log_and_warn "${_error} Adding ROS repository failed!"
       fi

    else
      _log_and_warn "${_repo} ROS is not supported on this distro/architecture!"
    fi # ros_arch_supported

  else
    _log_and_show "${_repo} Adding ROS repository is set to false, skipping..."
  fi # add_ros_repo


  # Visual Studio Code
  if [ "$add_vscode_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ]; then
      _log_and_show "${_repo} Visual Studio Code repository"
      _debug_log "Getting GPG keys for repository"
      wget -q https://packages.microsoft.com/keys/microsoft.asc -O /tmp/ae/microsoft.asc
      _debug_log "Adding Key to trusted GPG keys directory"
      apt-key add /tmp/ae/microsoft.asc 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" || _log_and_warn "${_error} Adding Visual Studio Code key failed"
      echo "deb [arch=$ARCH] https://packages.microsoft.com/repos/vscode stable main #Visual-Studio-Code" > ${SOURCES_FILE_DIR}/vscode.list
    else
      _log_and_warn "Architecture: $ARCH is not supported by Visual studio Code."
    fi
  else
    _log_and_show "${_repo} Visual Studio repository is set to false. Skipping."
  fi

  # Signal App
  if [ "$add_signal_repo" == "true" ]; then
   if [ "$ARCH" == "amd64" ]; then
      _log_and_show "${_repo} Signal repository"
      wget -q https://updates.signal.org/desktop/apt/keys.asc -O /tmp/ae/signal.asc >> "$log_file"
      apt-key add /tmp/ae/signal.asc  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_and_warn "${_error} Adding Signal Key Failed"
      echo "deb [arch=amd64] https://updates.signal.org/desktop/apt xenial main #Signal-for-Desktop"  > ${SOURCES_FILE_DIR}/signal-xenial.list
    else
        _log_and_warn "Architecture: $ARCH is not supported by Signal"
    fi
  else
    _log_and_show "${_repo} Signal repository is set to false. Skipping."
  fi

  # Kubernetes
  if [ "$add_kubernetes_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ] || [ "$ARCH" == "armhf" ] || [ "$ARCH" == "arm64" ] ; then
      wget -q https://packages.cloud.google.com/apt/doc/apt-key.gpg -O /tmp/ae/kubernetes.gpg >> "$log_file"
      apt-key add /tmp/ae/kubernetes.gpg  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_and_warn "${_error} Adding Kubernetes Key Failed"
      echo "deb http://apt.kubernetes.io/ kubernetes-${code_name} main #Kubernetes" > ${SOURCES_FILE_DIR}/kubernetes.list
    else
        _log_and_warn "Architecture: $ARCH is not supported. You might manually compile from source."
    fi
  else
    _log_and_show "${_repo} Kubernetes repository is set to false. Skipping."
  fi

  # Mendeley Desktop App
  if [ "$add_mendeley_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ] || [ "$ARCH" == "i386" ] ; then
      _log_and_show "${_repo} Mendeley repository"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 6F036044 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_and_warn "${_error} Adding Mendeley Desktop Key Failed"
      echo "deb https://desktop-download.mendeley.com/download/apt stable main #Mendeley-Desktop"  > ${SOURCES_FILE_DIR}/mendeleydesktop.list
    else
      _log_and_warn "${_warn} Architecture: ${ARCH} is not supported. You might manually compile from source."
    fi
  else
      _log_and_show "${_repo} Mendeley Desktop is set to false."
  fi


  # Duo Unix
  if [ "$add_duo_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ] || [ "$ARCH" == "i386" ] ; then
      case "$code_name" in
        bionic)     duo_repo_url="deb http://pkg.duosecurity.com/Ubuntu bionic main";
                    duo_supported="true"
                    ;;
        xenial)     duo_repo_url="deb http://pkg.duosecurity.com/Ubuntu xenial main"
                    duo_supported="true"
                    ;;
        trusty)     duo_repo_url="deb http://pkg.duosecurity.com/Ubuntu trusty main";
                    duo_supported="true"
                    ;;
        stretch)    duo_repo_url="deb http://pkg.duosecurity.com/Debian stretch main";
                    duo_supported="true"
                    ;;
        jessie)     duo_repo_url="deb http://pkg.duosecurity.com/Debian stretch main";
                    duo_supported="true"
                    ;;
        *)          _log_and_warn "Only LTS/Stable versions of Ubuntu/Debian are suported. You are running Unsupported version : ${code_name}"
      esac
      if [[ $duo_supported == "true" ]]; then
        # Repo keys for duosecurity
        _debug_log "Downloading GPG key..."
        wget -q https://duo.com/APT-GPG-KEY-DUO  -O /tmp/ae/duosecurity.gpg >> "$log_file"
        apt-key add /tmp/ae/duosecurity.gpg 2>&1 | _add_timestamp_to_logs "${_apt_key_logs}" \
        || _log_and_warn "${_error} Adding Kubernetes Key Failed"

        # Add repo
        echo "${duo_repo_url} #Duo Unix"  > ${SOURCES_FILE_DIR}/duounix.list
      fi
    else
        _log_and_warn "${_warn} Architecture: ${ARCH} is not supported. You might manually compile from source."
    fi
  else
        _log_and_show "${_repo} Duo Unix is set to false."
  fi

  # Enable Canonical Partner repos
  # Some Releases like linux mint have their own way of enabling partner Repositoris,
  # Disable adding partner Repositoris when using Ubuntu Derivatives like Linux Mint.
  # Default is true
  # _fix_ubuntu_derivatives will take care of this and bool_config_partner_repo is set to true only if
  # Ubuntu and its flavors are used.
  if [ "$bool_config_partner_repo" == "true" ] && [ "$bool_is_debian" != "true" ]; then
    _log_and_show "${_repo} Canonical partner repositoris"
    add-apt-repository "deb http://archive.canonical.com/ubuntu $code_name partner" >> "$log_file"
  else
    _log_and_show "${_warn} Canonical Partner repositoris may not be supported on this platform. They remain unchanged/unavailable."
  fi

  # Remove artifacts and keys
  _debug_log "Removing keys and converted files from current directory"
  (
    rm  -f /tmp/ae/*.gpg /tmp/ae/*.asc /tmp/ae/*.pub /tmp/ae/Release \
        /tmp/ae/*.Release /tmp/ae/*.key /tmp/ae/*.pub.* /tmp/ae/*.asc.* \
        /tmp/ae/*.key.* /tmp/ae/*.gpg.* >> "$log_file"
  )
  _line_fill >> "$log_file"

  update_repos

}


function update_repos()
{
  local exit_status
  _log_and_show "${_update} Repository index/metadata..."
  apt-get -q update 2>&1 | _add_timestamp_to_logs "${_apt_logs}"
  exit_status=$?
  if [[ $exit_status -eq 0 ]]; then
    _log_and_show "${_update} Success!"
  else
    set_red;
    _log_and_show "${_oh_no} Something went wrong in updating repo data. Please see the log file for more details."
    _log_and_show "${_error} Your system might end up completely broken and apt-get isn't reliable with this state."
    _log_and_show "${_error} The script cannot proceed with this."
    _log_and_exit "${_notice} Most of the times its either missing repository keys or wrongly configured repositories." "61"
    set_default;
  fi
}


function upgrade_apps()
{
  # This function will list upgradable apps and upgrade it.
  # IF Simulate is set to true this will only list the apps but no upgrade action will be performed.
  local exit_status
  _log_and_show "${_upgrade} Packages..."
  _debug_log "Listing Upgradable packages"
  _line_fill >> "$log_file"
  # upgradable is not available in apt-get ignore warning about apt being unstable
  apt list --upgradable 2>&1 | _add_timestamp_to_logs "${_apt_logs}"  \
  || _log_and_show "Something went wrong while listing upgradable packages. Please see the log file for more details."

  set_yellow;
  _debug_log "The above list of packages will be upgraded!"
  set_default;
  _debug_log "Upgrading packages..."
  # only do upgrades if simulate is set to false
  if [ "$simulate_apt_install" != "true" ]; then

    DEBIAN_FRONTEND=noninteractive apt-get -q -y upgrade | _add_timestamp_to_logs "${_apt_logs}"
    DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::='--force-confold' --force-yes -fuy dist-upgrade\
    | _add_timestamp_to_logs "${_apt_logs}"
    exit_status=$?
  else
    # If  simulate is true, set exit status as 0
    # Simulate flag skips the section above. No point in Checking for exit status
    set_blue;
    _log_and_show "${_simulate} is set to True. Not performing upgrade!"
    set_default;
    exit_status=0
  fi
  if [[ $exit_status -eq 0 ]]; then
    _log_and_show "${_upgrade} Completed successfully!"
  else
    _log_and_warn "${_oh_no} Something went wrong while upgrading packages."
    _log_and_warn "${_notice} Please see the log file for more details. \
    Most of the times its either missing repositories or wrongly configured repositories."
  fi
  set_default;
  # Cleanup APT cache (-k)
  _clean_apt_cache;

  _line_fill >> "$log_file"
}


function  upgrade_system()
{
  _debug_log "Updating and upgrading packages"
  update_repos;
  upgrade_apps;
}


function purge_ppa()
{
  # PPAs added or repositoris added by actions other than this script are not removed.
  # Simulate option has no effect on this function. PPAs will be purged irrespective of its value.
  local exit_status index dependency_packages
  dependency_packages=(ppa-purge)

  if [ "$bool_is_debian" == "false" ]; then
    _log_and_show "${_purge} PPAs"
    _install_dependencies "${dependency_packages[@]}"
      for index in "${parsed_ppa_list[@]}"; do
            _log_and_show "${_purge} $index..."
            _debug_log "Purging: $index"
            if [ "$index" == "" ] || [ "$index" == " " ]; then
              _log_and_warn "${_purge} Found an empty entry, Ignoring"
              continue;
            fi
            if ppa-purge -y "$index"  2>&1 | _add_timestamp_to_logs "${_apt_logs}"  ; then
              sleep 5 #wait sometimes apt lock isnt released soon.
              set_green
              _log_and_show "${_purge} $line successfully."
              set_default
            else
              _log_and_warn "${_oh_no} Some Error occured while purging $line."
            fi
        done
        set_yellow;
      _log_and_show "${_purge} External PPAs."

      # Clean -k flag.
      _clean_apt_cache;
      _log_and_show "${_purge} Complete. Please check the logs for errors."

    elif [ "$bool_is_debian" == "true" ]; then
      _log_and_show "PPA's are not available, because this is Debian."
    fi
}


function disable_external_repos()
{
  # Function to disable external repositoris added by this script.
  # PPAs added or repositoris added by actions other than this script are not removed.
  # Repositoris added by dpkg post install scripts and deb files will not be removed!!
  # Simulate option has no effect on this function. PPAs will be purged irrespective of its value.

    # Remove keys and list files.
    _log_and_show "${_deleting} Keys and external repositoris"
    _log_and_show "${_info} You can igore failed messages if those were not added in first place."
    set_default
    _log_and_show "${_deleting} Google signing key   7FAC5991"
    apt-key del 7FAC5991  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Google signing key -1 failed."

    _log_and_show "${_deleting} Google signing key   D38B4796"
    apt-key del D38B4796  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Google signing key -2 failed."

    _log_and_show "${_deleting} GCP signing key -2   BA07F4FB"
    apt-key del BA07F4FB  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Google cloud key -1 failed."

    _log_and_show "${_deleting} GCP signing key -2   A7317B0F"
    apt-key del A7317B0F  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  GCP signing key -2  failed."

    _log_and_show "${_deleting} Webupd8 signing key  4C9D234C"
    apt-key del 4C9D234C  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Webupd8 failed."

    _log_and_show "${_deleting} Spotify signing key  4C9D234C"
    apt-key del D2C19886  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Spotify signing key -3 failed."

    _log_and_show "${_deleting} Spotify signing key  48BF1C90"
    apt-key del 48BF1C90  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Spotify signing key -3 failed."

    _log_and_show "${_deleting} Spotify signing key  341D9410"
    apt-key del 341D9410  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Spotify signing key -2 failed."

    _log_and_show "${_deleting} Skype signing key    DF7587C3"
    apt-key del DF7587C3  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Skype for Linux keys failed."

    _log_and_show "${_deleting} WineHQ key [old]     5FCBF54A"
    apt-key del 5FCBF54A  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  WineHQ keys [old] failed."

    _log_and_show "${_deleting} WineHQ key [latest]  F987672F"
    apt-key del F987672F  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  WineHQ keys [latest] failed."

    _log_and_show "${_deleting} InSync signing key   ACCAF35C"
    apt-key del ACCAF35C  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  InSync keys failed."

    _log_and_show "${_deleting} Docker signing key   0EBFCD88"
    apt-key del 0EBFCD88  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Docker-CE keys failed."

    _log_and_show "${_deleting} VS-Code signing key  BE1229CF"
    apt-key del BE1229CF  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Visual Studio Code keys failed."

    _log_and_show "${_deleting} Signal signing key   57F6FB06"
    apt-key del 57F6FB06  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Signal keys failed."

    _log_and_show "${_deleting} Mendeley signing key 6F036044"
    apt-key del 57F6FB06  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  Mendeley Desktop keys failed."

    _log_and_show "${_deleting} ROS signing key B01FA116"
    apt-key del 421C365BD9FF1F717815A3895523BAEEB01FA116  2>&1 | _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_and_warn "${_deleting}  ROS keys failed."

    _log_and_show "${_repo} Removing external repositoris"
    _debug_log "${_deleting} *.list and *.save files from ${SOURCES_FILE_DIR}"
    (
      cd /etc/apt/sources.list.d &&
        rm  -f google-chrome.* \
        google-earth.* \
        skype-stable.* \
        spotify.* \
        insync.* \
        google-cloud-sdk.* \
        gcsfuse.* \
        docker.* \
        winehq.* \
        vscode.* \
        signal-xenial.* \
        mendeleydesktop.* \
        kubernetes.* \
        ros-latest.*
    )
    exit_status=$?
    set_yellow;
    if [[ $exit_status -eq 0 ]]; then
      _log_and_show "${_removed} Additional APT keys and repositories."
      _log_and_show "${_notice} Canonical partner repository was left unchanged."
    else
      _log_and_warn "${_oh_no} Failed to remove all or some of the list files or keys in Sources directory."
      _log_and_warn "${_notice} Please see the log file for more details."
    fi
    set_default;
    _log_and_show "${_removed} Repositories. Please check the logs for errors."

    _line_fill >> "$log_file"

}

function purge_not_required()
{
  # This function purges not required packages from the list ${dir}/data/purge.list
  # A flag -d MUST be passed for this option to work
  # Not passing a flag and choosing purge will result in error and acrion being aborted.
  # Simulate is not properly tested and use it with caution!
  # Combination of simulate and purge is UNSTABLE
  # You can modify -d requirement by setting the d_flag_passed=true
  # No validation/checks are done on the list file.
  # Action is dangerous if used carelessly eg. If you are stupid and remove say sudo (why would you??)

  local exit_status
  if [ "$bool_purge_not_required_pkgs" == "true" ]; then
    _log_and_show "${_purge} Packages..."
    if [[ ${#parsed_purge_packages[@]} -eq 0 ]]; then
      _log_and_warn "${_error} Package array is empty!";
      return;
    else
      if [ "$simulate_apt_install" == "true" ]; then
        set_yellow;
        _log_and_show "${_simulate} No packages will be purged!!"
        set_default;
      apt-get -q -y remove --purge --dry-run "${parsed_purge_packages[@]}" 2>&1 | _add_timestamp_to_logs "${_apt_logs}"
      else
        apt-get -q -y purge "${parsed_purge_packages[@]}" 2>&1 | _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?
      set_yellow
      if [[ $exit_status -eq 0 ]]; then
        set_green
        _log_and_show "${_purge} Success!"
      else
        _log_and_warn "${_oh_no} Something went wrong while purging packages."
        _log_and_warn "${_notice} Please see the log file for more details."
      fi
      set_default
    fi
  else
    _log_and_exit "${_error} Purge switch is set to false. Did you pass -d along wth the command?" "20"
  fi
  set_default;
  _line_fill >> "$log_file"

}


function install_apps()
{
  # Function to install apps mentioned in lists/arrays
  # external-repos should always be at last to avoid any errors in previous lists.
  # No checks are being made on any of the files for validity. One entry per line is recommended.
  # If a package is not available entire collection in the file *.list will not be installed!!

  # Accept some EULA
  update_repos;
  echo ttf-mscorefonts-installer msttcorefonts/accepted-mscorefonts-eula select true |  debconf-set-selections
  #Install starts here
  local packages exit_status index
  #shellcheck disable=SC2034
  readonly local package_arrays=(
                              administration
                              security
                              productivity
                              multimedia
                              development
                              other
                              external
                              )
  for array in "${package_arrays[@]}"; do
    case "${array}" in
      administration)         packages=("${parsed_administration_packages[@]}");;
      security)               packages=("${parsed_secutity_packages[@]}");;
      productivity)           packages=("${parsed_productivity_packages[@]}");;
      multimedia)             packages=("${parsed_multimedia_packages[@]}");;
      development)            packages=("${parsed_development_packages[@]}");;
      other)                  packages=("${parsed_other_packages[@]}");;
      external)               packages=("${parsed_external_packages[@]}");;
      *)                      _log_and_exit "${_error} Critical error. Invalid array type" "19";;
    esac
    _log_and_show "${_apt} Installing $array packages"

    # Chek if array is empty
    if [[ ${#packages[@]} -eq 0 ]]; then
      set_yellow;
      _log_and_show "${_notice} Package array is empty!";
      set_default;
      continue
    else
      _debug_log "Following packages will be installed."
      printf "[$(date)] ${_array} %s\n" "${packages[@]}" >> "${log_file}"
      # Check if simulate is true
      if [ "$simulate_apt_install" == "true" ]; then
        set_yellow;
        _log_and_show "${_simulate} package installation."
        set_default;
        apt-get -q -y install -s "${packages[@]}" | _add_timestamp_to_logs "${_apt_logs}"
      else
        apt-get -q -y install "${packages[@]}" | _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?
      unset packages;
      if [[ $exit_status -eq 0 ]]; then
        set_green
        _log_and_show "${_apt} Success!"
      else
      _log_and_warn "${_oh_no} Something went wrong while installing packages in $index."
      _log_and_warn "${_notice} Please see the log file for more details."
      fi
      set_default;

    fi
    unset packages
  done
  {
    _line_fill
    #declare -p
    _line_fill
  } >> "$log_file"
  # Delete DEBs
  _clean_apt_cache;

  _line_fill >> "$log_file"
}


function _install_pip_python()

{
  # Function to install python pip packages
  # This function reads from File ${dir}/data/pip.list contains list python packages to be installed system wide.
  # Arguments : Two
  # ARG1 : pip package list
  # ARG2 : 2 for python 2 and
  #      : 3 for Python 3.

  #Check args
  if [ $# -lt 1 ] ||  [ $# -gt 1 ] ; then
    set_yellow;
    _log_and_show "${_error} Incorrect number of arguments.\
     \n${_info} Usage: _check_and_install_pre_requisites <list.apt> <commands to check>\n" && \
    _log_and_exit "Internal Function Error. Invalid number of Arguments: $#." "19";
  fi;

  set_default;
  #Install starts here
  local exit_status pip_command pip_loc python_packages requirements_file
  local pip_ver="${1}"
  _debug_log "Option: Install Python packages via PIP, Function name: _install_pip_python"
  _debug_log "pip Version : ${pip_ver}"

  # Check Python Version
  case ${pip_ver} in
    2 | python2 )   readonly pip_command="pip"
                    dependency_packages=(python-pip)
                    python_packages=("${parsed_pip2_packages[@]}")
                    requirements_file="/tmp/ae/requirements2.txt"
                    ;;
    3 | python3 )   readonly pip_command="pip3";
                    dependency_packages=(python3-pip)
                    python_packages=("${parsed_pip3_packages[@]}")
                    requirements_file="/tmp/ae/requirements3.txt"
                    ;;
              * )   _log_and_exit "Internal Function Error. Arguments for python version." "19";;
  esac

  _log_and_show "${_checking} Dependencies for Python: ${pip_ver}"
  # Check if `python-pip` is installed, if not install it
  if ! pip_loc="$(type -p "$pip_command")" || [[ -z $pip_loc ]]; then
      _log_and_warn "${_info} $pip_command is not installed!${NC}"
      set_default;
      update_repos;
      _log_and_show "${_installing} PIP Dependencies"

      # Check if simulate flag is set
      if [ "$simulate_apt_install" == "true" ] && [ "$CI" != "true" ]; then
        set_yellow;
        _log_and_show "${_simulate} No Dependencies will be installed!!"
        set_default;
        # shellcheck disable=SC2086
        apt-get -q -y install -s "${dependency_packages[@]}" 2>&1 | _add_timestamp_to_logs "${_apt_logs}"
      else
        # shellcheck disable=SC2086
        apt-get -q -y install "${dependency_packages[@]}" 2>&1 | _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?

      if [[ $exit_status -eq 0 ]]; then
        _log_and_show "${_installed} Dependency packages."
      else
        _log_and_warn "${_oh_no} Something went wrong while installing dependencies."
        _log_and_warn "${_error} Python packages cannot be installed without dependencies."
        _log_and_exit "${_notice} Please see the log file for more details." "21"
      fi

      ## honor --keep-debs -k flags
      _clean_apt_cache;

  else
    _log_and_show "${_info} Dependency already satisfied."
  fi
  # reset exit status & color
  exit_status=0
  set_default;


  _log_and_show "${_installing} Installing python packages"
  _debug_log "Requirements file: ${requirements_file}"
   rm -f ${requirements_file} || _log_and_exit "Failed to remove ${requirements_file}" "38"
   printf "%s\n" "${python_packages[@]}" > "${requirements_file}"
  # Check if pip package list is empty
  if [[ ${#python_packages[@]} -eq 0 ]]; then
    _log_and_warn "${_error} Package array is empty!";
    return
  else
    # I package list isn't empty proceed to install pip packages
    # Check if simulate is true & is not running on TRAVIS/CI.
    if [ "$simulate_apt_install" == "true" ] && [ "$CI" != "true" ]; then
      set_yellow;
      _log_and_show "${_whoops} PIP does not support simulated installs. Not performing install."
      set_default;
    else
      $pip_command install -r "${requirements_file}" 2>&1 | _add_timestamp_to_logs "${_pip_logs}"
    fi
    exit_status=$?
    if [[ $exit_status -eq 0 ]]; then
      set_green
      _log_and_show "${_installed} python - ${1} modules"
    else
      _log_and_warn "${_error} Something went wrong while installing packages in $pip_list."
      _log_and_warn "${_notice} Please see the log file for more details."
    fi
    set_default
  fi

  set_default;

  _line_fill >> "$log_file"
}


function install_pip_packages_2()
{
  # Install Python 2 packages
  _install_pip_python "2"
}


function install_pip_packages_3()
{
  # Install Python 2 packages
  _install_pip_python "3"
}

function install_conda_packages()
{
  set_default;
  #Install starts here
  local conda_command="conda"
  local install_path="/opt/anaconda"
  local requirements_file="/tmp/ae/conda_requirements.txt"
  local conda_packages=("${parsed_conda_packages[@]}")
  local conda_install_url="${config__install__conda__url[0]}"
  local exec="${conda_install_url##*/}"
  local exit_status conda_loc

  _debug_log "Option: Install Python packages via Conda, Function name: install_conda_packages"

  # Check if "conda" is installed, if not install it
  if ! conda_loc="$(type -p "$conda_command")" || [[ -z $conda_loc ]]; then
      _log_and_warn "${_info} $conda_command is not installed!${NC}"
      set_default;

      # proceed to install conda
      _log_and_show "${_installing} conda. Running ${exec}"

      if [ "$simulate_apt_install" == "true" ] && [ "$CI" != "true" ]; then
        set_yellow;
        _log_and_show "${_simulate} No Dependencies will be installed!!"
        set_default;
      else
        # Remove the script if exists
        rm -f $exec

        # download and execute installation
        wget $conda_install_url 2>&1 | _add_timestamp_to_logs "${_conda_logs}"
        if [ $? -ne 0 ]; then
          _log_and_warn "${_error} Something went wrong while downloading $conda_install_url."
        fi

        bash $exec -b -p $install_path 2>&1 | _add_timestamp_to_logs "${_conda_logs}"
        rm -f $exec

        # Remove the write permission from group and others
        chmod -R go-w $install_path

        # Give read and execution permission to group and others
        chmod -R go+rX $install_path

        conda_command=${install_path}/bin/conda
      fi
  else
    _log_and_show "${_info} conda installation detected."
  fi

  # reset exit status & color
  exit_status=0
  set_default;

  _log_and_show "${_installing} Installing conda packages"
  _debug_log "Requirements file: ${requirements_file}"
  rm -f ${requirements_file} || _log_and_exit "Failed to remove ${requirements_file}" "38"
  printf "%s\n" "${conda_packages[@]}" > "${requirements_file}"

  # Check if package list is empty
  if [[ ${#conda_packages[@]} -eq 0 ]]; then
    _log_and_warn "${_error} Package array is empty!";
    return
  else
    # If package list isn't empty proceed to install conda packages
    # Check if simulate is true & is not running on TRAVIS/CI.
    if [ "$simulate_apt_install" == "true" ] && [ "$CI" != "true" ]; then
      set_yellow;
      _log_and_show "${_whoops} Conda does not support simulated installs. Not performing install."
      set_default;
    else
      while read requirement
      do
        ${conda_command} install -c conda-forge -y ${requirement} 2>&1 | _add_timestamp_to_logs "${_conda_logs}"

	      exit_status=$?
	      if [[ $exit_status -eq 0 ]]; then
            set_green
            _log_and_show "${_installed} $requirement"
        else
            _log_and_warn "${_error} Something went wrong while installing packages in $pip_list."
            _log_and_warn "${_notice} Please see the log file for more details."
        fi
	      set_default
      done < ${requirements_file}
    fi
  fi

  set_default;

  _line_fill >> "$log_file"
}

function install_debs ()
{

  # Function to get the deb files from DEB_URL in the ${dir}/data/deb_files.list
  # The list file has following format
  # URL to get the deb file  <space or tab> NAME_OF_THE_APP(without spaces)

  local index deb_url line deb_name
  local exit_status
  _debug_log "Option: Install DEB Files, Function name: install_debs"
  for index in "${parsed_deb_files_list[@]}"; do
    _debug_log "$index"
    deb_url=$(echo "$index" | cut -d ',' -f1 )
    deb_name=$(echo "$index" | cut -d ',' -f2 )
    _debug_log "DEB file url: $deb_url"
    _debug_log "DEB file name: $deb_name"
    _log_and_show "${_deb} Downloading $deb_name"
    wget -q "$deb_url" -O "${deb_name}" >> "$log_file"

   _log_and_show "${_deb} Installing - $deb_name..."
   # Check if simulate is true
   if [ "$simulate_apt_install" == "true" ]; then
     set_yellow
     _log_and_show "${_simulate} $deb_name Installation!!"
     set_default
     dpkg -i --dry-run "$deb_name" 2>&1 | _add_timestamp_to_logs "${_dpkg_logs}"
     _debug_log "Installing missing packages..."
     apt-get -q -y install -f 2>&1 | _add_timestamp_to_logs "${_apt_logs}"
     exit_status=$?
    else
      dpkg -i "$deb_name" 2>&1 | _add_timestamp_to_logs "${_dpkg_logs}"
      _debug_log "Installing missing packages..."
      apt-get -q -y install -f 2>&1 | _add_timestamp_to_logs "${_apt_logs}"
      exit_status=$?
    fi

    # shellcheck disable=SC2181
     if [ "$exit_status" = "0" ]; then
       set_green
      _log_and_show "${_deb} Installed $deb_name successfully."
     else
      _log_and_warn "${_oh_no} Some error occured during downloading and installing $index."
      $?="0"
    fi
    set_default
    # Delete DEBs
    if [ "$bool_preserve_debs" == "false" ];then
      _log_and_show "${_deb} Deleting ownloaded DEB Packages"
      (
        rm -f "${dir}/${deb_name}" >> "$log_file"
      )
    else
      _debug_log "Keeping Downloaded DEB Packages"
    fi
  done

  _clean_apt_cache;
  _line_fill >> "$log_file"
}


function install_binaries ()
{

  # Function to get the binaries files from URL in the ${dir}/data/bin.list
  # The list file has following format
  # <URL>,<filename>
  # If ypu want to specify relative path you
  # can do so relative to /usr/local/bin
  # Be careful not to rename existing ones

  local index bin_url line bin_name
  local exit_status
  _debug_log "Option: Install Bin Files, Function name: install_binaries"
  # Check if simulate is true
  for index in "${parsed_bin_packages[@]}"; do
    _debug_log "$index"
    bin_url=$(echo "$index" | cut -d ',' -f1 )
    bin_name=$(echo "$index" | cut -d ',' -f2 )
    _debug_log "BIN file url: $bin_url"
    _debug_log "BIN file name: $bin_name"
    _log_and_show "${_info} Downloading $bin_name"
    {
      wget -q "$bin_url" -O "/tmp/ae/${bin_name}" >> "$log_file"
    } ||
    {
      _log_and_show "${_error} Downloading $bin_name failed."
      continue
    }
    exit_status="$?"
    if [ $exit_status -eq 0 ]; then
      _log_and_show "${_installing} $bin_name..."
       if [ "$simulate_apt_install" == "true" ]; then
         set_yellow
         _log_and_show "${_simulate} Skipping Installation!!"
         set_default
       else
        {
          cp -rf "/tmp/ae/${bin_name}" /usr/local/bin/"${bin_name}"
        } || _log_and_show "${_error} Failed to copy $bin_name";
        _debug_log "Setting Permissions..."
        chmod +x /usr/local/bin/"$bin_name" >> "${log_file}"
      fi
    else
      _log_and_warn "${_error} Failed to download $bin_name."
    fi
    set_default
  done
  _line_fill >> "$log_file"
}


function _autopilot_check_task_flag_and_run()
{
  # checks flags set for each task/function and runs it
  # Arguments Two
  # ARG -1 : global flag variable to check
  # ARG -2: Function Name to execute
  local flag=${1}
  local runnable=${2}

  if [ "${flag}" == "true" ]; then
    _debug_log "Executing Function $runnable"
    "$runnable"
  else
    _debug_log "Task : $runnable is not enabled"
  fi
  unset runnable
}


function all_in_one()
{
  #Wrapper for all options
  _debug_log "Option: ALL IN ONE, function name: all_in_one"
  _line_fill;
  set_default;
  update_repos;
  upgrade_apps;
  add_ppas;
  add_repositories;
  install_apps;
  install_debs;
  install_pip_packages_2;
  install_pip_packages_3;
  install_conda_packages;
  purge_not_required;
  install_binaries;
  _line_fill;
  set_default;
}


function _process_menu
{
  local whiptail_exitstatus task COLUMNS LINES
  _debug_log "Processing Options"
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  #export COLUMNS LINES
  # shellcheck disable=SC2086
  task=$(whiptail \
      --notags \
      --backtitle "$SCRIPT" \
      --title "Ubuntu Post-Install Script" \
      --menu "\nWhat would you like me to do?\nCheck the logs for details and errors." \
      --cancel-button "Quit" \
      $LINES $COLUMNS $(( LINES - 12 )) \
      update     'Update Repository Metadata' \
      upgrade    'Upgrade Packages' \
      all        'APT+PIP+PPA+REPO+DEB=All' \
      repo       'Add Repositories' \
      ppas       'Add PPAs' \
      purge      'Purge not required packages' \
      apps       'Install Packages' \
      debs       'Install DEB packages' \
      pip2       'Install Python 2 packages via pip' \
      pip3       'Install Python 3 packages via pip3' \
      conda      'Install Python packages via conda' \
      bin        'Download & Install Static Binaries' \
      repo_rst   'Reset Repositories for cleanup' \
      ppa_rst    'Purge PPAs' \
      logdel     'Delete Script logs' \
      3>&1 1>&2 2>&3)

    whiptail_exitstatus=$?
    _debug_log "Whiptail Exit status is : $whiptail_exitstatus"
    if [ $whiptail_exitstatus = 0 ]; then
      _debug_log "Whiptail Choice is: $task"
      case $task in
      update)     _show_confirmation_dialog_for_tasks \
                  "Update APT index" \
                  "Update Repositories index/metadata?" \
                  "update_repos"
                  ;;
      upgrade)    _show_confirmation_dialog_for_tasks \
                  "Upgrade Packages" \
                  "This will upgrade all installed packages to the latest version.\n\nContinue?"
                  "upgrade_apps"
                  ;;
      ppas)       _show_confirmation_dialog_for_tasks "Add Additional PPAs" \
                  "This will add PPAs specified in config file.\n\nWould you like to continue?" \
                  "add_ppas"
                  ;;
      repo)       _show_confirmation_dialog_for_tasks "Add Additional Repositories" \
                  "Adding additional repositories is set as follows.\n Google Chrome & Google Earth : $add_google_repo,\n Google Cloud SDK : $add_googlecloud_repo\n Visual Studio Code : $add_vscode_repo\n Docker : $add_docker_repo\n Insync : $add_insync_repo\n Spotify : $add_spotify_repo\n Wine-HQ : $add_winehq_repo\n Skype : $add_skype_repo\n Kubernetes : $add_kubernetes_repo\n Signal Desktop : $add_signal_repo.\n Shall I do it?" \
                  "add_repositories"
                  ;;
      apps)       _show_confirmation_dialog_for_tasks \
                  "Install Apps" \
                  "I can Install the packages listed in lists files.\nNo checks are being made on the validity of the list.\n\nShall I do it?" \
                  "install_apps"
                  ;;
      repo_rst)   _show_confirmation_dialog_for_tasks \
                  "Remove External Repositories" \
                  "I can remove External Repositories added and PPAs in the ppa.list. Apps installed via ppa will be reverted to original versions/uninstalled.\n\nShall I do it for you?" \
                  "disable_external_repos"
                  ;;
      ppa_rst)    _show_confirmation_dialog_for_tasks "Purge PPAs is ppa.list or mentioned in config."\
                  "PPAs listed in ppa.list or under YAML key config.ppa will be purged.\nhis will install ppa-purge on your system.\n\n Continue"
                  "purge_ppa"
                  ;;
      purge)      _show_confirmation_dialog_for_tasks \
                  "Purge Unwanted Packages" \
                  "Shall I Purge Unwanted packages mentioned in purge.list?" \
                  "purge_not_required"
                  ;;
      all)        _show_confirmation_dialog_for_tasks \
                  "All In One" "This task will do the following.\nUpdate Repositories\nUpgrade Packages\nAdd Repositories and PPAs\nInstall apps from List\nPurge Unwanted Packages\n\nContinue?" \
                  "all_in_one"
                  ;;
      debs)       _show_confirmation_dialog_for_tasks \
                  "Download & Install DEB files" "DEB Files in the list deb-files.list will be Download and installed. Proceed with the task?" \
                  "install_debs"
                  ;;
      pip2)       _show_confirmation_dialog_for_tasks \
                  "Install Python2 packages" "Python packaes for Python 2 mentioned in pip.list will be installed via pip. If necessary python-pip package will be installed from apt. \n\nProceed?" \
                  "install_pip_packages_2"
                  ;;
      pip3)       _show_confirmation_dialog_for_tasks \
                  "Install Python3 packages" \
                  "Python packaes for Python 3 listed in pip3.list will be installed via pip. If necessary python3-pip package will be installed from apt.\n\nProceed?" \
                  "install_pip_packages_3"
                  ;;
      conda)       _show_confirmation_dialog_for_tasks \
                  "Install conda packages" \
                  "Conda packages for listed in conda.list will be installed via conda. If necessary conda package will be installed from apt.\n\nProceed?" \
                  "install_conda_packages"
                  ;;
      bin)        _show_confirmation_dialog_for_tasks \
                  "Install Static Binaries" \
                  "Download & Install binaries listed in bin.list or config.install.binaries?" \
                  "install_binaries"
                  ;;
      log)        _debug_log "Delete log selected"
                  delete_log_file;
                  ;;
    esac
    else
      _debug_log "Whiptail Exit code : $whiptail_exitstatus"
      _debug_log "Exiting because user selected Quit or Whiptail has non zero exit code."
    fi
}


function _ci_cloud_and_container_checks()
{
  _log_and_show "${_running} Some checks..."
  # Check if running in CI & Containers
  # VMs, GCP, AWS, Docker. If running in CI Assign AUTOPILOT=true

  #================================ CI =============================================
  if [ "$TRAVIS" == "true" ]; then
    AUTOPILOT="true"
    bool_say_yes_to_all="true"
    _log_and_show "${_ci} Running in Travis CI :|"
  elif [ "$APPVEYOR" == "true" ]; then
    AUTOPILOT="true"
    bool_say_yes_to_all="true"
    _log_and_show "${_ci} Running in Appveyor CI :|"
  elif [ "$CI" == "true" ]; then
    AUTOPILOT="true"
    bool_say_yes_to_all="true"
    _log_and_show "${_ci} I'm running in  CI :|"
  else
    _debug_log "Probably not running in a CI"
  fi

  if [ "$(uname -r | cut -f3 -d '-')" == "Microsoft" ]; then
    set_yellow
    _log_and_show "${_warn} Running on Windows Subsystem for Linux."
    set_default
  fi
  #============================ Docker =============================================
  if grep docker /proc/1/cgroup -qa; then
    _log_and_show "${_info} Running in Docker."
  else
    _debug_log "Probably not running in docker"
  fi
  #------------------------------- EC2, GCP, DO ------------------------------------
  # This first, simple check will work for many older instance types.
  if [ -f /sys/hypervisor/uuid ] && [ "$(head -c 3 /sys/hypervisor/uuid)" == "ec2" ]; then
    _log_and_show "${_info} Running on EC2"

  # This check will work on newer m5/c5 instances, but only if you have root!
  # If the file exists AND is readable by us, we can rely on it.
  elif [ -r /sys/devices/virtual/dmi/id/product_uuid ] && [ "$(head -c 3 /sys/devices/virtual/dmi/id/product_uuid)" == "EC2" ]; then
    _log_and_show "${_info} Running on EC2"

  # Fallback check of http://169.254.169.254/. If we wanted to be REALLY
  # authoritative, we could follow Amazon's suggestions for cryptographically
  # verifying their signature, see here:
  #    https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html
  # but this is almost certainly overkill for this purpose (and the above
  # checks of "EC2" prefixes have a higher false positive potential, anyway).
  elif wget -O- -q --timeout=5 --tries=3 http://169.254.169.254/latest/dynamic/instance-identity/document | grep -q availabilityZone; then
    _log_and_show "${_info} Running on EC2"

  #------------------------------- GCP ---------------------------------------------
  elif wget -q -O- --timeout=5 --tries=3 -nc --header="Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/virtual-clock/drift-token > /dev/null; then
    _log_and_show "${_info} Running on Google Compute"

  elif wget -q -O- --timeout=5 --tries=3 -nc  http://169.254.169.254/metadata/v1/id; then
    _log_and_show "${_info} Running on Digital Ocean Droplet"
  else
    _debug_log "Probably not running on AWS, GCP or Digital Ocean."
  fi

}

function display_version()
{
  #_line_fill
  set_green
  printf "%-15s : %s\n" "Version Number" "${REL_NUM}"
  set_yellow
  printf "%-15s : %s\n" "Version Name" "${REL_NAME}"
  set_red
  printf "%-15s : %s\n" "Executable" "${SCRIPT}"
  set_default
  #_line_fill
}


function _process_non_root_options()
{
  # Process command line arguments which does not require root.
  while [ "${1}" != "" ]; do
    case ${1} in
      -v | --version)   display_version;exit 0;;
      --verify)         verify_gpg_signature;exit 0;;
    esac
    shift
  done
}


function main()
{
  _init_printf_variables

  # Display Version Info and Verify signature options
  _process_non_root_options "$@"

  _line_fill;
  printf "${_checking} Permissions...\n"
  if [[ $EUID -ne 0 ]]; then
    set_red;
    printf "${_whoops} Insufficinet privilages!!\n"
    set_default;
    printf "${_whoops} This script must be run as root.\n"
    printf "${_notice} Please use sudo ${dir}/$SCRIPT to run this as root.\n"
    _line_fill;
    exit 2;
  else
    # Actual logging starts
    _init_logging
    _debug_log "OK! running as root."
  fi
  _init_script_variables;


  # Process command line arguments.
  while [ "${1}" != "" ]; do
    case ${1} in
      -s | --simulate )       readonly simulate_apt_install="true";
                              set_yellow;
                              _log_and_show "${_simulate} is set to true";
                              set_default;
                              ;;
      -f | --fix )            bool_fix_repo_not_available_for_latest="true";
                              set_yellow;
                              _log_and_show "${_fix_repo} is set to true. Using codename: $codename_previous_release.";
                              set_default;
                              ;;
      -p | --pre-release )    bool_fix_repo_not_available_for_upcoming_release="true";
                              set_magenta;
                              _log_and_show "${_fix_repo} for upcoming release is set to true.";
                              set_default;
                              ;;
      -d | --purge )          bool_purge_not_required_pkgs="true";
                              set_yellow;
                              _log_and_show "${_purge} Purge packages is set to true."
                              _log_and_show "${_warn} No checks are being made on the Packages in the list."
                              _log_and_show "${_warn} Use carefully!. Purging something like sudo is stupid idea!"
                              set_default;
                              ;;
      -y | --yes )            bool_say_yes_to_all="true";
                              set_yellow;
                              _log_and_show "${_warn} Will automatically assume yes, for all the confirmation dialogs.";
                              set_default;
                              ;;
      -l | --delete-log )     delete_log_file;;
      -k | --keep-debs )      set_default;
                              bool_preserve_debs="true";
                              _log_and_show "${_info} Will keep downloaded DEB packages."
                              ;;
      -R | --remote-yaml )    set_default;
                              _log_and_show "${_info} Using Remote YAML"
                              readonly bool_remote_yaml="true";
                              shift; readonly url_remote_yaml="${1}";
                              ;;
      --no-version-checks )   bool_check_version="false"
                              ;;
      -S |  --no-stats )      set_yellow;
                              readonly bool_report_stats="false";
                              _log_and_show "${_info} Statistis will not be reported."
                              set_default;
                              ;;
      -C | --config-file )    shift;
                              readonly custom_config_file="${1}";
                              readonly bool_custom_config_file="true"
                              _log_and_show "${_info} Using custom config file"
                              ;;
      -V | --version-file )   shift;
                              readonly custom_version_file="${1}";
                              readonly bool_custom_version_file="true"
                              _log_and_show "${_info} Using custom version yml file"
                              ;;
      -Y | --yaml )           readonly bool_use_yaml="true";
                              set_yellow;
                              _log_and_show "${_info} Using YAML config..."
                              set_default;
                              ;;
      --use-default-yaml)     readonly bool_use_default_yaml="true";
                              ;;
      -L | --lists)           readonly bool_use_lists="true";
                              set_yellow;
                              _log_and_show "${_info} Using local Lists..."
                              set_default;
                              ;;
      -n | --name)            shift;
                              readonly bool_custom_remote_config_name="true";
                              readonly custom_remote_config_name="${1}";;
      --hide-config)          readonly bool_hide_config="true";
                              _log_and_show "${_info} YAML config will not be displayed."
                              ;;
      --internal)             ae_internal="true"
                              ;;
      --use-uf-mirror | -u)   _log_and_show "Will use Uni-Freiburg mirror(s) if available";
                              readonly bool_use_uni_freiburg_mirror="true";
                              ;;
      -v | --version )        _log_and_show "-v or --version should be the only argument." "23";;
      --verify)               _log_and_exit "--verify should be the only argument." "23";;
       * )                    _log_and_exit "${_error} Invalid option: $1" "22";;
    esac
    shift
  done


  # Initialize variables and checks
  local after_effects_core_dependencies=(wget lsb_release whiptail ping ps grep cut tr)
  _check_dependencies "${after_effects_core_dependencies[@]}"

  _init_print_basic_info;

  # I dont like when someone else is occupying my room
  # Test if any apt-get ops are running
  _test_conflicting_apps;

  # Did I tell you that I need to call My friends over internet?
  _test_internet_connection;

  # Checks CI & Containers If running on EC2 or GCP0
  _ci_cloud_and_container_checks;

  # Take care of Mint and other distros
  _fix_ubuntu_derivatives;

 # Set API Endpoints
  _set_custom_api_nodes;

  if [ "$bool_custom_config_file" == "true" ] && [ "$bool_remote_yaml" == "true" ]; then
    _log_and_exit "${_error} Cannot use local config (-C) with remote YAML (-R) Use one of them." "25"
  fi

  if [ "$bool_custom_config_file" == "true" ] && [ ! -f "$custom_config_file" ]; then
    _log_and_exit "${_error} Custom config file you have specified is not found or not accessible" "36"
  fi
  if [ "$bool_custom_version_file" == "true" ] && [ ! -f "$custom_version_file" ]; then
    _log_and_exit "${_error} Custom version info file you have specified is not found or not accessible" "36"
  fi
  if [ "$bool_custom_remote_config_name" == "true" ] && [ "$custom_remote_config_name" == "" ]; then
    _log_and_exit "${_error} Custom remote config cannot be empty" "39"
  fi

  # Get Remote Config File/s, check version & configure
  _version_checks;

  if [ "$bool_use_yaml" == "true" ] && [ "$bool_use_lists" != "true" ]; then
   _set_yaml_config;
  elif [ "$bool_use_lists" == "true" ] && [ "$bool_use_yaml" != "true" ]; then
    _set_list_config;
  elif  [ "$bool_use_lists" == "true" ] && [ "$bool_use_yaml" == "true" ]; then
    _log_and_exit "${_error} -Y --yaml and -L --lists cannot be used together." "25"
  else
    _log_and_warn "${_error} You need to specify config type to use."
    _log_and_exit "${_info} -Y or --yaml for YAML or -L or --lists for Lists" "25"
  fi

  # Autopilot
  if [[ "$AUTOPILOT" == "true" ]]; then
    set_blue;
    bool_say_yes_to_all="true"
    _log_and_show "${_autopilot} is Active"
    sleep 5;
    set_default
    #_log_and_exit "Because I can" "255"
    _autopilot_check_task_flag_and_run "$ae_task_update" "update_repos"
    _autopilot_check_task_flag_and_run "$ae_task_upgrade" "upgrade_apps"
    _autopilot_check_task_flag_and_run "$ae_task_repo" "add_repositories"
    _autopilot_check_task_flag_and_run "$ae_task_ppa" "add_ppas"
    _autopilot_check_task_flag_and_run "$ae_task_apt" "install_apps"
    _autopilot_check_task_flag_and_run "$ae_task_debs" "install_debs"
    _autopilot_check_task_flag_and_run "$ae_task_pip2" "install_pip_packages_2"
    _autopilot_check_task_flag_and_run "$ae_task_pip3" "install_pip_packages_3"
    _autopilot_check_task_flag_and_run "$ae_task_conda" "install_conda_packages"
    _autopilot_check_task_flag_and_run "$ae_task_purge" "purge_not_required"
    _autopilot_check_task_flag_and_run "$ae_task_bin" "install_binaries"
  else
  _process_menu;
  #_log_and_show "DEBUG: Options Processed"
  fi

  _script_exit_log;
}

#Run Main
main "$@"
